# cpp基础精讲

## 数据类型的别名typedef

创建数据类型的别名有两个目的：

l 为名称复杂的类型创建别名，方便书写和记忆。

l 创建与平台无关的数据类型，提高程序的兼容性。

语法：typedef 原数据类型名 别名;

C++11还可以用using关键字创建数据类型的别名。

语法：using 别名=原数据类型名;

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	// 1）为名称复杂的类型创建别名，方便书写和记忆。
	// 2）创建与平台无关的数据类型，提高程序的兼容性。
	// 在VS中，short是两个字节，int是四个字节，long也是四个字节，long long是八个字节。
	typedef short         int16_t;    // 16位的整数。
	typedef int             int32_t;    // 32位的整数。
	typedef long long int64_t;    // 64位的整数。
	// 在Linux中，short是两个字节，int是四个字节，long也是八个字节，long long也是八个字节。
	typedef short         int16_t;    // 16位的整数。
	typedef int             int32_t;    // 32位的整数。
	typedef long          int64_t;    // 64位的整数。

	// 在程序源代码中，只使用别名int16_t、int32_t、int64_t，不使用原名。
}
```

## 指针的基本概念

### 变量的地址

变量是内存变量的简称，在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的。

![image-20230924170849040](./photo/image-20230924170849040.png)

C++用运算符&获取变量在内存中的起始地址。

语法：&变量名

### 指针变量

指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的**起始地址**。

语法：数据类型 *变量名;

数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。

星号*与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。

### 对指针赋值

不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。我们用整型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；用浮点型指针存放浮点型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址。

语法：指针=&变量名;

注意

- 对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。

- 如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型。

### 指针占用的内存

指针也是变量，是变量就要占用内存空间。

在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。

### 使用指针

声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。

指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）

运算符被称为**间接值**或**解除引用（解引用）**运算符，将它用于指针，可以得到该地址的内存中存储的值，*也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。

**变量和指向变量的指针就像同一枚硬币的两面。**

![image-20230924171420150](./photo/image-20230924171420150.png)



程序在存储数据的时候，必须跟踪三种基本属性：

- 数据存储在哪里；

- 数据是什么类型；

- 数据的值是多少。

用两种策略可以达到以上目的：

声明一个普通变量，声明时指出数据类型和变量名（符号名），系统在内部跟踪该内存单元。

声明一个指针变量，存储的值是地址，而不是值本身，程序直接访问该内存单元。

## 指针用于函数的参数

如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为**地址传递**或**传地址**。

**值传递**：函数的形参是普通变量。

传地址的意义如下：

- 可以在函数中修改实参的值。

- 减少内存拷贝，提升性能。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

// 调用函数的时候，调用者把数值赋给了函数的参数。
// 实参：调用者程序中书写的在函数名括号中的参数。
// 形参：函数的参数列表。
void func(int *no, string *str)    // 向先生表白的函数。 
{
	cout << "亲爱的" << *no << "号：" << *str << endl;
	*no = 8;
	*str = "我有一只小小鸟。";
}

// 写一个函数，从3名先生的身高数据中，选出最高的和最矮的。
void func1(int a, int b, int c, int* max, int* min)
{
	*max = a > b ? a : b;               // 取a和b中的大者。
	*min = a < b ? a : b;                // 取a和b中的小者。
	*max = *max > c ? *max : c;   // 取*max和c中的大者。
	*min = *min < c  ? *min : c;    // 取*min和c中的大者。
}

int main()
{
	int bh = 3;      // 编号。
	string message = "我是一只小猪。";          // 内容。

	func(&bh, &message);            // 调用向先生表白的函数。
	/*{
		int *no = &bh;          
		string *str = &message; 

		cout << "亲爱的" << *no << "号：" << *str << endl;
		*no = 8;
		*str = "我有一只小小鸟。";
	}*/

	cout << "亲爱的" << bh << "号：" << message << endl;

	// 从3名先生的身高数据中，选出最高的和最矮的。
	int a = 180, b = 170, c = 175, m, n;
	func1(a, b, c, &m, &n);
	cout << "m=" << m << ",n=" << n << endl;
}

```

## 用const修饰指针

### 常量指针

语法：const 数据类型 *变量名;

不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。

注意：

- 指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。

- 一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。

- 如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。

- 如果形参的值不需要改变，建议加上const修饰，程序可读性更好。

### 指针常量

语法：数据类型 * const 变量名;

指向的变量（对象）不可改变。

注意：

- 在定义的同时必须初始化，否则没有意义。

- 可以通过解引用的方法修改内存地址中的值。

- C++编译器把指针常量做了一些特别的处理，改头换面之后，有一个新的名字，叫引用。

### 常指针常量

语法：const 数据类型 * const 变量名;

指向的变量（对象）不可改变，不能通过解引用的方法修改内存地址中的值。叫常引用。

常量指针：指针指向可以改，指针指向的值不可以更改。

指针常量：指针指向不可以改，指针指向的值可以更改。

常指针常量：指针指向不可以改，指针指向的值不可以更改。

**记忆秘诀：\*表示指针，指针在前先读指针；指针在前指针就不允许改变。**

常量指针：const 数据类型 *变量名

指针常量：数据类型 * const 变量名

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func(const int *no, const string *str)    // 向先生表白的函数。 
{
	// *no = 8;
	// *str = "我有一只小小鸟。";
	cout << "亲爱的" << *no << "号：" << *str << endl;
}
int main()
{
	int a = 3, b = 8;
	// 常量指针的语法：const 数据类型* 变量名;
	// 不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。
	/*const int* p = &a;
	a = 13;
	cout << "a=" << a << ",*p=" << *p << endl;
	p = &b;
	cout << "b=" << b << ",*p=" << *p << endl;*/
	// 指针常量语法：数据类型* const 变量名;
	// 指向的变量（对象）不可改变；在定义的同时必须初始化；可以通过解引用的方法修改内存地址中的值。
	int* const p=&a;
	*p = 13;
	cout << "a=" << a << ",*p=" << *p << endl;

	//int bh = 3;      // 先生的编号。
	//string message = "我是一只小猪。";          // 向先生表白的内容。
	//
	//func(&bh, &message);            // 调用向先生表白的函数。

	//cout << "亲爱的" << bh << "号：" << message << endl;
}
```

## void关键字 

在C++中，void表示为**无类型**，主要有三个用途：

1）函数的返回值用void，表示函数没有返回值。

```
void func(int a,int b){
  // 函数体代码。
  return;
}
```

2）函数的参数填void，表示函数不需要参数（或者让参数列表空着）。

```
int func(void){
  // 函数体代码。
  return 0;
}
```

3）函数的形参用void \*，表示接受任意数据类型的指针。

注意：

- 不能用void声明变量，它不能代表一个真实的变量，但是，用void *可以。

- 不能对void *指针直接解引用（需要转换成其它类型的指针）。

- 把其它类型的指针赋值给void*指针不需要转换。

- 把void *指针赋值给把其它类型的指针需要转换。    

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
// 只关心地址本身，不关心里面的内容，用void *可以存放任意类型的地址。
// 显示变量的十六进制地址的函数：varname-变量名，p-变量的地址。
void func(string varname, void* p)
{
	cout << varname<< "的地址是：" << p << endl;
	cout << varname << "的值是：" << *(char *)p << endl;
}
int main()
{
	int    a=89;
	char b='X';
	cout << "a的地址是：" <<  & a << endl;
	cout << "b的地址是：" <<  & b << endl;
	func("a", &a);
	func("b", & b);
}
```

## C++内存模型

在 C++ 中，程序运行时，内存主要分成四个区，分别是**栈、堆、数据段**和**代码段**。

![image-20230924175441102](./photo/image-20230924175441102.png)

**栈：**存储局部变量、函数参数和返回值。

**堆：**存储动态开辟内存的变量。

**数据段：**存储全局变量和静态变量。

**代码段：**存储可执行程序的代码和常量（例如字符常量），此存储区不可修改。

**栈和堆的主要区别：**

**1****）管理方式不同：栈是系统自动管理的，在出作用域时，将自动被释放；堆需手动释放，若程序中不释放，程序结束时由操作系统回收。**

**2****）空间大小不同：堆内存的大小受限于物理内存空间；而栈就小得可怜，一般只有8M（可以修改系统参数)。**

3）分配方式不同：堆是动态分配；栈有静态分配和动态分配（都是自动释放）。

4）分配效率不同：栈是系统提供的数据结构，计算机在底层提供了对栈的支持，进栈和出栈有专门的指令，效率比较高；堆是由C++函数库提供的。

5）是否产生碎片：对于栈来说，进栈和出栈都有着严格的顺序（先进后出），不会产生碎片；而堆频繁的分配和释放，会造成内存空间的不连续，容易产生碎片，太多的碎片会导致性能的下降。

6）增长方向不同：栈向下增长，以降序分配内存地址；堆向上增长，以升序分配内存地址。

## 动态分配内存new和delete

使用堆区的内存有四个步骤：

1）声明一个指针；

2）用new运算符向系统申请一块内存，让指针指向这块内存；

3）通过对指针解引用的方法，像使用变量一样使用这块内存；

4）如果这块内存不用了，用delete运算符释放它。

申请内存的语法：new 数据类型(初始值);  // C++11支持{}

如果申请成功，返回一个地址；如果申请失败，返回一个空地址（暂时不考虑失败的情况）。

​    释放内存的语法：delete 地址;

释放内存不会失败（还钱不会失败）。

注意：

- 动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。

- **如果动态分配的内存不用了，必须用delete释放它，否则有可能用尽系统的内存。**

- 动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。

- 就算指针的作用域已失效，所指向的内存也不会释放。

- 用指针跟踪已分配的内存时，不能跟丢。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	// 1）声明一个指针；
	// 2）用new运算符向系统申请一块内存，让指针指向这块内存；
	// 3）通过对指针解引用的方法，像使用变量一样使用这块内存；
	// 4）如果这块内存不用了，用delete运算符释放它。
	// 申请内存的语法：new 数据类型(初始值);   // C++11支持{}
	// 释放内存的语法：delete 地址;
	int* p = new int(5);
	cout << "*p=" << *p << endl;
	*p = 8;
	cout << "*p=" << *p << endl;
	delete p;

	/*	for (int ii = 1; ii > 0; ii++)
	{
		int* p = new int[100000];     // 一次申请100000个整数，这个语法以后再讲。
		cout << "ii="<<ii<<",p=" << p << endl;
	}/*
}
```

## 二级指针

**指针**是**指针变量**的简称，也是**变量**，是**变量**就有**地址**。

**指针**用于存放**普通变量**的**地址**。

**二级指针**用于存放**指针变量**的**地址**。

声明二级指针的语法：数据类型** 指针名;

使用指针有两个目的：1）传递地址；2）存放动态分配的内存的地址。

在函数中，如果传递普通变量的地址，形参用指针；**传递指针的地址，形参用二级指针。**

把普通变量的地址传入函数后可以在函数中修改变量的值；**把指针的地址传入函数后可以在函数中指针的值。**

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func(int **pp)
{
	*pp = new int(3);
	cout << "pp=" << pp << ",*pp=" << *pp << endl;
}

int main()
{
	/*int ii = 8;               cout << "ii=" << ii << ",ii的地址是：" << &ii << endl;
	int* pii = &ii;        cout << "pii=" << pii << ",pii的地址是：" << &pii << ",*pii=" << *pii << endl;
	int** ppii = &pii;  cout << "ppii=" << ppii << ",ppii的地址是：" << &ppii << ",*ppii=" << *ppii << endl;
	cout << "**ppii=" << **ppii << endl;*/

	int* p=0;
	func(&p);
	/*{
		int** pp = &p;
		*pp = new int(3);
		cout << "pp=" << pp << ",*pp=" << *pp << endl;
	}*/

	cout << "p=" << p << ",*p=" << *p << endl;
}
```

## 空指针

在C和C++中，用0或NULL都可以表示空指针。

声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。

### 使用空指针的后果

**如果对空指针解引用，程序会崩溃。**

**如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。**

**在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。**

为什么空指针访问会出现异常？

NULL指针分配的分区：其范围是从 0x00000000到0x0000FFFF。这段空间是空闲的，对于空闲的空间而言，没有相应的物理存储器与之相对应，所以对这段空间来说，任何读写操作都是会引起异常的。空指针是程序无论在何时都没有物理存储器与之对应的地址。为了保障“无论何时”这个条件，需要人为划分一个空指针的区域，固有上面NULL指针分区。

### C++11的nullptr

用0和NULL表示空指针会产生歧义，C++11建议用nullptr表示空指针，也就是(void *)0。

NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用nullptr替代NULL吧，而NULL就当做0使用。

**注意：在Linux平台下，如果使用nullptr，编译需要加-std=c++11参数。**

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func(int* no, string* str)    // 向先生表白的函数。 
{
	if ((no == 0) || (str == 0)) return;  

	cout << "亲爱的" << *no << "号：" << *str << endl;
}

int main()
{
	// int bh = 3;      // 先生的编号。
	// string message = "我是一只小猪。";          // 向先生表白的内容。
	int* bh = 0;   //  new int(3);
	string* message = 0; //  new string("我是一只小猪。");
	
	func(bh,message);            // 调用向先生表白的函数。

	delete bh; delete message;
}
```

## 野指针

野指针就是指针指向的不是一个有效（合法）的地址。

在程序中，如果访问野指针，**可能**会造成程序的崩溃。

出现野指针的情况主要有三种：

1）指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。

2）如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。

3）指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收），让指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针。

规避方法：

1）指针在定义的时候，如果没地方指，就初始化为nullptr。

2）动态分配的内存被释放后，将其置为nullptr。

3）函数不要返回局部变量的地址。

注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，**可能**会造成程序的崩溃。是可能，不是一定，程序的表现是**不稳定**，增加了调试程序的难度。

## 函数指针

函数的二进制代码存放在内存四区中的代码段，函数的地址是它在内存中的起始地址。如果把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。

使用函数指针的三个步骤：

a）声明函数指针；

b）让函数指针指向函数的地址；

c）通过函数指针调用函数。

### 声明函数指针

声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指**返回值**和**参数列表**（函数名和形参名不是）

假设函数的原型是：

```
int func1(int bh,string str);
int func2(int no,string message);
int func3(int id,string info);
bool func4(int id,string info);
bool func5(int id);
```

则函数指针的声明是：

```
int  (*pfa)(int,string);
bool (*pfb)(int,string);
bool (*pfc)(int);
```

pfa、pfb、pfc是函数指针名，必须用括号，否则就成了返回指针的函数。

### 函数指针的赋值

函数名就是函数的地址。

函数指针的赋值：函数指针名=函数名;

### 函数指针的调用

```
(*函数指针名)(实参);
函数指针名(实参);
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func(int no, string str)
{
	cout << "亲爱的" << no << "号：" << str << endl;
}

int main()
{
	int bh = 3;                                                 // 先生的编号。
	string message = "我是一只小猪。";    // 向先生表白的内容。

	func(bh, message);

	void (*pfunc)(int, string);           // 声明表白函数的函数指针。
	pfunc = func;                              // 对函数指针赋值，语法是函数指针名=函数名。
	pfunc(bh, message);                  // 用函数指针名调用函数。 C++
	(*pfunc)(bh, message);              // 用函数指针名调用函数。 C语言
}
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
void zs(int a)         // 张三的个性化表白函数。
{
	cout  <<"a=" << a << "我要先翻三个跟斗再表白。\n";   // 个性化表白的代码。
}
void ls(int a)         // 李四的个性化表白函数。
{
	cout << "a=" << a << "我有一只小小鸟。\n";   // 个性化表白的代码。
}
void show(void (*pf)(int),int b)
{
	cout << "表白之前的准备工作已完成。\n";       // 表白之前的准备工作。
	pf(b);                                                                     // 用函数指针名调用个性化表白函数。
	cout << "表白之后的收尾工作已完成。\n";       // 表白之后的收尾工作。
}

int main()
{
	show(zs, 3);          // 张三要表白。
	show(ls, 4);          // 李四要表白。
}
```

## 一维数组的基本概念

数组是一组数据类型相同的变量，可以存放一组数据。

### 创建数组

声明数组的语法：数据类型 数组名[数组长度];

注意：数组长度必须是整数，可以是常量，也可以是**变量和表达式**。

C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。

### 数组的使用

可以通过下标访问数组中元素，数组下标从0开始。

数组中每个元素的特征和使用方法与单个变量完全相同。

语法：数组名[数组下标]

注意：

- 数组下标也必须是整数，可以是常量，也可以是**变量**。

- 合法的数组下标取值是：**0~(数组长度-1)**。

### 数组占用内存的情况

数组在内存中占用的空间是连续的。

用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。

### 数组的初始化

声明的时候初始化：

```
数据类型 数组名[数组长度] = { 值1，值2，值3, ...... , 值n};
数据类型 数组名[ ] = { 值1，值2，值3, ...... , 值n};
数据类型 数组名[数组长度] = { 0 };  // 把全部的元素初始化为0。
数据类型 数组名[数组长度] = { };    // 把全部的元素初始化为0。
```

注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。C++11标准可以不写等于号。

### 清空数组

用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）

```
函数原型：void *memset(void *s, int c, size_t n);
```

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

### 复制数组

用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）

```
函数原型：void *memcpy(void *dest, const void *src, size_t n);
```

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	int bh[] = {3, 6, 1,6,7,4,3,5,6,7,8,322,2,3,9};               // 先生编号。
	string name[3];    // 先生姓名。
	
	for (int ii = 0; ii < sizeof(bh)/sizeof(int); ii++)
	{
		cout << "bh["<<ii<<"]=" << bh[ii] << endl;
	}

	int bh1[sizeof(bh) / sizeof(int)];   // 数组长度必须是整数，可以是常量，也可以是变量和表达式。

	memcpy(bh1, bh, sizeof(bh));      // 把数组bh中的内容复制到bh1。    

	for (int ii = 0; ii < sizeof(bh1) / sizeof(int); ii++)
	{
		cout << "bh1[" << ii << "]=" << bh1[ii] << endl;
	}
}
```

## 一维数组和指针

### 指针的算术

将一个整型变量加1后，其值将增加1。

但是，将指针变量（地址的值）加1后，增加的量等于它指向的数据类型的字节数。

### 数组的地址

a）数组在内存中占用的空间是连续的。

b）C++将数组名解释为数组第0个元素的地址。

c）数组第0个元素的地址和数组首地址的取值是相同的。

d）数组第n个元素的地址是：数组首地址+n

e）C++编译器把  数组名[下标] **解释为**  *(数组首地址+下标)

### 数组的本质

数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的。

### 数组名不一定会被解释为地址

在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数。

可以修改指针的值，但数组名是常量，不可修改。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	char a;      cout << "sizeof(char)=" << sizeof(char) << endl;            // 1字节
	short b;    cout << "sizeof(short)=" << sizeof(short) << endl;         // 2字节
	int c;         cout << "sizeof(int)=" << sizeof(int) << endl;                  // 4字节
	double d; cout << "sizeof(double)=" << sizeof(double) << endl;   // 8字节
		
	cout << "a的地址是：" << (void *)& a << endl;
	cout << "a的地址+1是：" << (void*)( & a + 1) << endl;

	cout << "b的地址是：" << (void*)&b << endl;
	cout << "b的地址+1是：" << (void*)(&b + 1) << endl;

	cout << "c的地址是：" << (void*)&c << endl;
	cout << "c的地址+1是：" << (void*)(&c + 1) << endl;

	cout << "d的地址是：" << (void*)&d << endl;
	cout << "d的地址+1是：" << (void*)(&d + 1) << endl;
}
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	double a[5];

	cout << "a的值是：" << (long long) a << endl;
	cout << "&a的值是：" << (long long)&a << endl;

	cout << "a[0]的地址是：" << (long long) &a[0] << endl;
	cout << "a[1]的地址是：" << (long long) &a[1] << endl;
	cout << "a[2]的地址是：" << (long long) &a[2] << endl;
	cout << "a[3]的地址是：" << (long long) &a[3] << endl;
	cout << "a[4]的地址是：" << (long long) &a[4] << endl;

	double* p = a;
	cout << "p的值是：" << (long long)p << endl;
	cout << "p+0的值是：" << (long long)(p+  0) << endl;
	cout << "p+1的值是：" << (long long)(p + 1) << endl;
	cout << "p+2的值是：" << (long long)(p + 2) << endl;
	cout << "p+3的值是：" << (long long)(p + 3) << endl;
	cout << "p+4的值是：" << (long long)(p + 4) << endl;
}
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	int a[5] = { 3 , 6 , 5 , 8 , 9 };

	// 用数组表示法操作数组。
	cout << "a[0]的值是：" << a[0] << endl;
	cout << "a[1]的值是：" << a[1] << endl;
	cout << "a[2]的值是：" << a[2] << endl;
	cout << "a[3]的值是：" << a[3] << endl;
	cout << "a[4]的值是：" << a[4] << endl;

	// 用指针表示法操作数组。
	int* p = a;
	cout << "*(p+0)的值是：" << *(p+  0) << endl;
	cout << "*(p+1)的值是：" << *(p + 1) << endl;
	cout << "*(p+2)的值是：" << *(p + 2) << endl;
	cout << "*(p+3)的值是：" << *(p + 3) << endl;
	cout << "*(p+4)的值是：" << *(p + 4) << endl;
}
```

### 一维数组用于函数的参数

### 指针的数组表示

在C++内部，用指针来处理数组。

C++编译器把  数组名[下标] **解释为**  *(数组首地址+下标)

C++编译器把  地址[下标] **解释为**  *(地址+下标)

### 一维数组用于函数的参数

一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。

书写方法有两种： 

```
void func(int* arr, int len);
void func(int arr[], int len);
```

注意：

在函数中，可以用数组表示法，也可以用指针表示法。

在函数中，不要对指针名用sizeof运算符，它不是数组名。

其中用int *arr 替换了int arr []。这证明这两个函数头都是正确的，因为在 C++中，当(且仅当)用于函数头或函数原型中，int \*arr 和 int arr [ ]的含义才是相同的。它们都意味着arr是一个int 指针。然而，数组表示法 (int arr[ ])提醒用户，arr 不仅指向int，还指向int数组的第一个int。当指针指向数组的第一个元素时，本书使用数组表示法；而当指针指向一个独立的值时，使用指针表示法。别忘了，在其他的上下文中，int\* arr和int arr[ ]的含义并不相同。例如，不能在函数体中使用int tip[]来声明指针。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	char a[20];             // 这是一个长度为20的字符型数组。

	int* p = (int *)a;        // 让整型指针p指向数组a的内存。

	for (int ii = 0; ii < 6; ii++)
	{
		p[ii] = ii + 300;     // 用数组表示法操作指针。
	}

	for (int ii = 0; ii < 6; ii++)
	{
		cout << "*(p+" << ii << ")的值是：" << *(p + ii) << endl;    // 地址[下标]  解释为  *(地址+下标)。
	}
}
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

// void func(int *arr,int len)
void func(int arr[],int len)
{
	for (int ii = 0; ii < len; ii++)
	{
		cout << "arr[" << ii << "]的值是：" << arr[ii] << endl;              // 用数组表示法操作指针。
		cout << "*(arr+" << ii << ")的值是：" << *(arr + ii) << endl;   // 地址[下标]  解释为  *(地址+下标)。
	}
}

int main()
{
	int a[] = {2,8,4,6,7,1,9};
	
	func(a, sizeof(a) / sizeof(int));
}
```

### 用new动态创建一维数组

普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存。

动态创建一维数组的语法：数据类型 *指针=new 数据类型[数组长度];

释放一维数组的语法：delete [] 指针;

注意：

- 动态创建的数组没有数组名，不能用sizeof运算符。

- 可以用数组表示法和指针表示法两种方式使用动态创建的数组。

- 必须使用delete[]来释放动态数组的内存（不能只用delete）。

- 不要用delete[]来释放不是new[]分配的内存。

- 不要用delete[]释放同一个内存块两次（否则等同于操作野指针）。

- 对空指针用delete[]是安全的（释放内存后，应该把指针置空nullptr）。

- 声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。

- 如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。

- 为什么用delete[]释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	int *arr=new int[8];          // 创建8个元素的整型数组。

	for (int ii = 0; ii < 8; ii++)
	{
		arr[ii] = 100 + ii;                                                                  // 数组表示法。
		cout << "arr[" << ii << "]=" << *(arr + ii) << endl;        // 指针表示法。
	}
	delete[]arr;
}
```

## 一维数组的排序qsort

qsort()函数用于对各种数据类型的数组进行排序。

函数的原型：

```
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
```

第一个参数：数组的起始地址。

第二个参数：数组元素的个数（数组长度）。

第三个参数：数组元素的大小（sizeof(数组的数据类型)）。

第四个参数：回调函数的地址。

回调函数决定了排序的顺序，声明如下：

```
int compar(const void *p1, const void *p2);
```

1）如果函数的返回值< 0 ，那么p1所指向元素会被排在p2所指向元素的前面。

2）如果函数的返回值==0，那么p1所指向元素与p2所指向元素的顺序不确定。

3）如果函数的返回值> 0 ，那么p1所指向元素会被排在p2所指向元素的后面。

```
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
```

qsort()函数的其它细节：

- 形参中的地址用void是为了支持任意数据类型，在回调函数中必须具体化。

- 为什么需要第三个形参size_t size？

- size_t是C标准库中定义的，在64位系统中是8字节无符号整型（unsigned long long）。

typedef unsigned long long size_t

- 排序的需求除了升序和降序，还有很多不可预知的情况，只能用回调函数。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int compasc(const void* p1, const void* p2)         // 升序的回调函数。
{
	return *((int*)p1) - *((int*)p2);
}

int compdesc(const void* p1, const void* p2)       // 降序的回调函数。
{
	return *((int*)p2) - *((int*)p1);
}
```

```
int main()
{
	int a[8] = { 4,2,7,5,8,6,1,3 };

	qsort(a,sizeof(a)/sizeof(int),sizeof(int),compasc);                   // 对数组a进行升序排序。

	for (int ii = 0; ii < 8; ii++)
	{
		cout << "a[" << ii << "]=" << a[ii] << endl;
	}

	qsort(a, sizeof(a) / sizeof(int), sizeof(int), compdesc);            // 对数组a进行降序排序。

	for (int ii = 0; ii < 8; ii++)
	{
		cout << "a[" << ii << "]=" << a[ii] << endl;
	}
}
```

## 一维数组的查找-二分查找

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

// 在arr中查找key，成功返回key在arr中的数组下标，失败返回-1。
int search(int arr[], int len, int key)
{
	int low = 0, high = len-1,mid;          // 初始化：low=0，high=数组长度-1。

	while (low <= high)
	{
		mid = (low + high) / 2;     // 计算mid指针的位置。

		if (arr[mid] == key) return mid;         // 查找成功。     
		else if (arr[mid] > key) high = mid - 1;  // 继续在前半区查找。
		else low = mid + 1;                    // 继续在后半区查找。
	
	}

	return -1; // 查找失败。
}

int main()
{
	int a[10] = { 7,9,12,16,21,25,30,35,41,48 };    // 必须是已排好序的数组。

	if (search(a, 10, 30) >= 0) cout << "在数组a中查找30成功。\n";
	else cout << "在数组a中查找30失败。\n";
}
```

## C风格的字符串

C语言约定：如果字符型（char）数组的末尾包含了空字符\0（也就是0），那么该数组中的内容就是一个字符串。  ![image-20230924182116787](./photo/image-20230924182116787.png)              

因为字符串需要用0结尾，所以在声明字符数组的时候，要预留多一个字节用来存放0。

```
char name[21];  // 声明一个最多存放20个英文字符或十个中文的字符串。
```

### 初始化方法

```
char name[11];                 // 可以存放10个字符，没有初始化，里面是垃圾值。
char name[11] = "hello";         // 初始内容为hello，系统会自动添加0。
char name[]   = { "hello" };      // 初始内容为hello，系统会自动添加0，数组长度是6。
char name[11] = { "hello" };      // 初始内容为hello，系统会自动添加0。
char name[11]   { "hello" };      // 初始内容为hello，系统会自动添加0。C++11标准。
char name[11] = { 0 };          // 把全部的元素初始化为0。
```

### 清空字符串

```
memset(name,0,sizeof(name));   // 把全部的元素置为0。
name[0]=0;       // 不规范，有隐患，不推荐。
```

### 字符串复制或赋值strcpy()

```
char *strcpy(char* dest, const char* src);
```

功 能: 将参数src字符串拷贝至参数dest所指的地址。

返回值: 返回参数dest的字符串起始地址。

复制完字符串后，会在dest后追加0。

**如果参数dest所指的内存空间不够大，会导致数组的越界。**

### 字符串复制或赋值strncpy()

```
char * strncpy(char* dest,const char* src, const size_t n);
```

功能：把src前n个字符的内容复制到dest中。

返回值：dest字符串起始地址。

如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。

**如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。**

**如果参数dest所指的内存空间不够大，会导致数组的越界。**

### 获取字符串的长度strlen()

```
 size_t  strlen( const char*  str);
```

功能：计算字符串的有效长度，不包含0。

返回值：返回字符串的字符数。

strlen()函数计算的是字符串的实际长度，遇到0结束。

### 字符串拼接strcat(）

```
char *strcat(char* dest,const char* src);
```

功能：将src字符串拼接到dest所指的字符串尾部。

返回值：返回dest字符串起始地址。

dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。

**如果参数dest所指的内存空间不够大，会导致数组的越界。**

### 字符串拼接strncat()

```
char *strcat(char* dest,const char* src);
```

功能：将src字符串拼接到dest所指的字符串尾部。

返回值：返回dest字符串起始地址。

dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。

**如果参数dest所指的内存空间不够大，会导致数组的越界。**

### 字符串拼接strncat()

```
char *strncat (char* dest,const char* src, const size_t n);
```

功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。

返回值：返回dest字符串的起始地址。

如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n小于字符串src的长度，只追加src的前n个字符。

strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。

**如果参数dest所指的内存空间不够大，会导致数组的越界。**

### 字符串比较strcmp()和strncmp()

```
int strcmp(const char *str1, const char *str2 );
```

功能：比较str1和str2的大小。

返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；

```
int strncmp(const char *str1,const char *str2 ,const size_t n);
```

功能：比较str1和str2前n个字符的大小。

返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；

两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。

在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。

### 查找字符strchr()和strrchr()

```
const char *strchr(const char *s, int c);
```

返回在字符串s中第一次出现c的位置，如果找不到，返回0。

```
const char *strrchr(const char *s, int c);
```

返回在字符串s中最后一次出现c的位置，如果找不到，返回0。

### 查找字符串strstr()

```
char *strstr(const char* str,const char* substr);
```

功能：检索子串在字符串中首次出现的位置。

返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。

### 用于string的表达式

可以把C风格的字符串用于包含了string类型的赋值拼接等表达式中。

### 注意事项

a）字符串的结尾标志是0，按照约定，在处理字符串的时候，会从起始位置开始搜索0，一直找下去，找到为止（不会判断数组是否越界）。

b）结尾标志0后面的都是垃圾内容。

c）**字符串在每次使用前都要初始化**，减少入坑的可能，**是每次，不是第一次**。

d）不要在子函数中对字符指针用sizeof运算，所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。

e）在VS中，如果要使用C标准的字符串操作函数，要在源代码文件的**最上面**加:

```
#define _CRT_SECURE_NO_WARNINGS
```

```
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	char name[11];

	memset(name, 0, sizeof(name));
	// name[0] = 0;
	// strcpy(name, "hello");
	strncpy(name, "hello", 3);

	cout << "name=" << name << endl;

	cout << "name[0]=" << (int)name[0] << endl;
	cout << "name[1]=" << (int)name[1] << endl;
	cout << "name[2]=" << (int)name[2] << endl;
	cout << "name[3]=" << (int)name[3] << endl;
	cout << "name[4]=" << (int)name[4] << endl;
	cout << "name[5]=" << (int)name[5] << endl;
	cout << "name[6]=" << (int)name[6] << endl;
	cout << "name[7]=" << (int)name[7] << endl;
	cout << "name[8]=" << (int)name[8] << endl;
	cout << "name[9]=" << (int)name[9] << endl;
	cout << "name[10]=" << (int)name[10] << endl;
}
```

## 二维数组

一维数组的数学概念是线性表，二维数组的数学概念是矩阵。

### 创建二维数组

声明二维数组的语法：数据类型 数组名[行数][列数];

注意：数组长度必须是整数，可以是常量，也可以是**变量和表达式**。

C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。

### 二维数组的使用

可以通过行下标和列下标访问二维数组中元素，下标从0开始。

二维数组中每个元素的特征和使用方法与单个变量完全相同。

语法：数组名[行下标][列下标]

注意：

- 二维数组下标也必须是整数，可以是常量，也可以是**变量**。

- 合法的行下标取值是：**0~(行数-1)**。

- 合法的列下标取值是：**0~(列数-1)**。

### 二维数组占用内存的情况

用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）。

二维数组在内存中占用的空间是连续的。

### 二维数组的初始化

声明的时候初始化：

```
数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 },...... };
数据类型 数组名[行数][列数] = { 数据1，数据2，数据3，数据4, ......};
数据类型 数组名[ ][列数] = { 数据1，数据2，数据3，数据4,......};
数据类型 数组名[行数][列数] = { 0 };  // 把全部的元素初始化为0。
数据类型 数组名[行数][列数] = { };    // 把全部的元素初始化为0。
```

注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。C++11标准可以不写等于号。

### 清空二维数组

用memset()函数可以把二维数组中全部的元素清零。（只适用于C++基本数据类型）

```
函数原型：void *memset(void *s, int c, size_t n);
```

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

### 复制二维数组

用memcpy()函数可以把二维数组中全部的元素复制到另一个相同大小的**数组（没说多少维）**。（只适用于C++基本数据类型）

```
函数原型：void *memcpy(void *dest, const void *src, size_t n);
```

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	// int bh[2][3] = { {11,12,13},{21,22,23} };                              // 声明一个两行三列的二维数组，存放先生的编号。
	// int bh[2][3] = { 11,12,13,21,22,23 };
	int bh[][3] = { 11,12,13,21,22,23 };

	/*bh[0][0] = 11;		bh[0][1] = 12;    bh[0][2] = 13;
	bh[1][0] = 21; 	bh[1][1] = 22;    bh[1][2] = 23;*/
	
	/*cout << "bh[0][0] = " << bh[0][0] << "  bh[0][1] = " << bh[0][1] << "  bh[0][2] = " << bh[0][2] << endl;
	cout << "bh[1][0] = " << bh[1][0] << "  bh[1][1] = " << bh[1][1] << "  bh[1][2] = " << bh[1][2] << endl;*/

	for (int ii = 0; ii < 2; ii++)                 // 第一层循环表示行数，循环继续的条件是计数器小于行数。
	{
		for (int jj = 0; jj < 3; jj++)              // 第二层循环表示列数，循环继续的条件是计数器小于列数。
		{
			cout << "&bh["<<ii<<"]["<<jj<<"] = " << (long long) & bh[ii][jj] << "  ";          // 处理二维数组的每个元素。
		}
		cout << endl;          // 每处理一行数据后，输出一个换行。
	}

	int* p = (int *)bh;

	for (int ii = 0; ii < 6; ii++)
	{
		cout << "p[" << ii << "]=" << p[ii] << endl;     // 一维数组的数组表示法。
	}
}
```



## 二维数组用于函数的参数

````
int* p;      // 整型指针。
int* p[3];   // 一维整型指针数组，元素是3个整型指针（p[0]、p[1]、p[2]）。
int* p();    // 函数p的返回值类型是整型的地址。
int (*p)(int ,int);   // p是函数指针，函数的返回值是整型。
````

### 行指针（数组指针）

```
声明行指针的语法：数据类型 (*行指针名)[行的大小];  // 行的大小即数组长度。
int (*p1)[3];  // p1是行指针，用于指向数组长度为3的int型数组。
int (*p2)[5];  // p2行指针，用于指向数组长度为5的int型数组。
double (*p3)[5];  // p3是行指针，用于指向数组长度为5的double型数组。
```

（1）一维数组名被解释为数组第0个元素的地址。

（2）对一维数组名取地址得到的是数组的地址，是行地址。

### 二维数组名是行指针

```c++
int bh[2][3] = {{11,12,13}，{21,22,23}}
```

bh 是二维数组名，该数组有 2 两元素，每一个元素本身又是一个数组长度为 3 的整型数组

bh 被解释为数组长度为 3 的整型数组类型的行地址。

如果存放 bh 的值，要用数组长度为 3 的整型数组类型的行指针。
```
int (*p)[3]=bh;
```

### 三维数组

```
int bh[4][2][3]
```

bh 是三维数组名，该数组有4两元素，每一个元素本身又是一个2行3 列的二维数组。

bh 被解释为2行3列的二维数组类型的二维地址。

如果存放 bh 的值，要用2 行3 列的二维数组类型的行指针。

```
int (*p)[2][3]=bh;
```

### 把二维数组传递给函数

如果要把 bh传给函数，函数的声明如下:

```
void func(int (*p)[3],int len)
void func(int p[][3],int len)
```

## 结构体的基本概念

结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。使用结构体有两个步骤:

### 定义结构体描述(类型)：

定义结构体描述的语法:
```
struct 结构体名{
成员一的数据类型 成员名;
成员二的数据类型 成员名二;
成员三的数据类型 成员名三;
成员n的数据类型 成员名 n;
}
```

注意：

- 结构以名是标识符。
- 结构体的成员可以是任意数据类型。
- 定义结构体描述的代码可以放在程序的任何地方，一般放在 main 函数的上面或头文件中。
- 结构体成员可以用C++的类(如 string)，但是不提倡。
- 在C++中，结构体中可以有函数，但是不提倡。
- 在C++11中，定义结构体的时候可以指定初始值。

### 创建结构体变量。

```
struct 结构体名 结构体变量名
```

也可以为结构体成员赋初始值。
```
struct 结构体名 结构体变量名={成员一的值成员二的值, .....，成员n 的值)
```

C++11 可以不写等于号。如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为 0
```
struct 结构体名 结构体变量名={0);
```

注意：

- c++中，struct关键字可以不写
- 可以在定义结构体的时候创建结构体变量。

### 使用结构体。

在c++程序中，使用成员运算符（.）来访问结构体中的每个成员。结构体中的每个成员具备普通变量的全部特征。

语法：结构体变量名.结构体成员名

### 占用内存的大小

- 用sizeof运算符可以得到整个结构体占用内存的大小。注意:整个结构体占用内存的大小不一定等于全部成员占用内存之和。
- 内存对齐：#pragma pack(字节数）
- 合理使用内存对齐规则，某些节省内存的做法可能毫无意义。

### 清空结构体

- 创建的结构体变量如果没有初始化，成员中有垃圾值。

- 用memset()函数可以把结构体中的全部成员清零。（只适用于c++基本的数据类型）

```
void *memset(void *dst,int val,size_t size);
```

- bzero()函数也可以用于清空结构体。

```
void * bzero(void *dst,size_t size);
```

### 复制结构体

- 用memcpy()函数可以把结构体中的全部的元素复制到另一个相同类型的结构体。（只适用于c++基本的数据类型）
- 也可以直接用等号（只适用于c++基本的数据类型）

## 结构体指针

结构体是一种自定义的数据类型，用结构体可以创建结构体变量。

### 基本语法

在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。如下：

```
struct st_girl girl; // 声明结构体变量 girl。
struct st_girl *pst=&girl; // 声明结构体指针，指向结构体变量 girls。
```


通过结构体指针访问结构体成员有两种方法:

```
(*指针名).成员变量名 //(*pst).name 和(*pst).age
指针名->成员变量名   //pst->name和pst->age
```

在第一种写法中，圆点的优先级高于\*,（\*指针名)两边的括号不能少。如果去掉括号写成\*指针名.成员变量名，那么相当于*(指针名.成员变量名)意义就完全不一样了。
在第二种写法中，->是一个新的运算符。上面的两种写法是等效的，程序员通常采用第二种写法，更直观。

- 与数组不一样，结构体变量名没有被解释位地址。

### 用于函数的参数

- 如果要把结构体传递给函数，实参取结构体的地址，函数的形参用结构体指针
- 如果不希望在函数中修改结构体的值，可以对形参加 const 约束。

### 用于动态分配内存

用结构体指针指向动态分配的内存的地址。

```
st_girl* stgirl = new st_girl;
memset(stgirl, 0, sizeof(st_girl));
```

## 结构体数组

- 结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。
- 声明结构体数组的语法：struct 结构体类型 数组名[数组长度]
- 初始化结构体数组，要结合使用初始化数组的规则和初始化结构体的规则。

```
struct st_girl girls[2]={{"西施",26,43.8,'X',true),{"西瓜",25,52.8,'Y',false}};
```

- 使用结构体数组可以用数组表示法，也可以用指针表示法。

## 结构体嵌入数组和结构体

```
struct st_girl{
	char name[21];
	int score[2][3]={11,12,13,21,22,23};
	int age;
	double weight;
	char sex;
	bool yz;
};
void func(st_girl* pst){
	for(int ii=0;ii<2;ii++){
		for(int jj=0;jj<3;jj++)
			cout<<"pst->score["<<ii<<"]["<<jj<<"]="<<pst->score[ii][jj]<<endl;
	}
}
int main(){
	st_girl girl;
	func(&girl);
}
```

```
struct st_pet{
	char name[21];
	char type[21];
}
struct st_girl{
	char name[21];
	int age;
	double weight;
	char sex;
	bool yz;
	struct st_pet pet;
};
int main(){
	st_girl girl={"西施",26,43.8,'X',true,{"bb","yy"}};
	girl={"西瓜" ,26,43.8,'X',true,{"bb","yt"}};//c++11标准语法
	girl.pet={"ss","gg"};//c++11标准语法
}
```

## 结构体中的指针

如果结构体中的指针指向的是动态分配的内存地址:

- 对结构体用sizeof 运算可能没有意义。
- 对结构体用memset()函数可能会造成内存泄露。

## 简单链表

如果结构体中有一个本结构体的指针，它就是链表。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

struct st_girl     // 女孩单链表。
{
	int      no;                      // 女孩编号。
	string name;                 // 女孩姓名。
	struct st_girl* next;      // 下一个女孩节点的地址，如果本节点是最后一条记录，填nullptr。
};

int main()
{
	st_girl *head = nullptr, *tail = nullptr, *tmp = nullptr;    // head头指针、tail尾指针、tmp临时指针。

	tmp=new st_girl({ 1, "西施", nullptr });      // 分配第一个节点。
	head = tail = tmp;

	tmp = new st_girl({ 6, "冰冰", nullptr });      // 分配第二个节点。
	tail->next = tmp;     // 把上一个节点的next指针指向新节点。
	tail = tmp;                 // 移动尾指针，让尾指针指向刚分配出来的新节点。

	tmp = new st_girl({ 3, "幂幂", nullptr });      // 分配第三个节点。
	tail->next = tmp;     // 把上一个节点的next指针指向新节点。
	tail = tmp;                 // 移动尾指针，让尾指针指向刚分配出来的新节点。

	// 遍历链表。
	tmp = head;             // 从头节点开始。
	while (tmp != nullptr)
	{
		cout << "no=" << tmp->no << "name=" << tmp->name << "tmp->next=" << tmp->next << endl;
		tmp = tmp->next;   // 顺着next指向往后面找。
	}
	
	// 释放链表。
	while (head != nullptr)
	{
		tmp = head;               // 让临时节点指向头节点。
		head = head->next;  // 头节点后移。
		delete tmp;                 // 删除临时节点。
	}
}
```

## 共同体

共同体（共用体、联合体）是一种数据格式，它能存储不同的数据类型，但是，在同一时间只能存储其中的一种类型。声明共同体的语法：

```
union 共同体名
{
成员一的数据类型  成员名一;
成员二的数据类型  成员名二;
成员三的数据类型  成员名三;
......
成员n的数据类型  成员名n;
};
```

注意：

- 共同体占用内存的大小是它最大的成员占用内存的大小（内存对齐）。

- 全部的成员使用同一块内存。

- 共同体中的值为最后被赋值的那个成员的值。

- 匿名共同体没有名字，可以在定义的时候创建匿名共同体变量（VS和Linux有差别），也可以嵌入结构体中。

应用场景：

- 当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间（嵌入式系统）。

- 用于回调函数的参数（相当于支持多种数据类型）。

```
#define  _CRT_SECURE_NO_WARNINGS
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

union          // 声明共同体udata。
{
	int        a;
	double b;
	char     c[25];
} data;

int main()
{
	// udata data;     // 定义共同体变量。

	cout << "sizeof(data)=" << sizeof(data) << endl;

	cout << "data.a的地址是：" << (void*)&data.a << endl;
	cout << "data.b的地址是：" << (void*)&data.b << endl;
	cout << "data.c的地址是：" << (void*)&data.c << endl;
	
	data.a = 3;
	data.b = 8.8;
	strcpy(data.c, "我是一只小猪。");
	cout << "data.a=" << data.a << endl;
	cout << "data.b=" << data.b << endl;
	cout << "data.c=" << data.c << endl;
}
```

```
#define  _CRT_SECURE_NO_WARNINGS
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

struct st_girl       // 声明女孩结构体。
{
	int no;             // 女孩编号。
	union              // 声明匿名共同体。
	{
		int        a;
		double b;
		char     c[21];
	};
};

int main()
{
	struct st_girl girl;

	cout << "girl.a的地址是：" << (void*) &girl.a << endl;
	cout << "girl.b的地址是：" << (void*) &girl.b << endl;
	cout << "girl.c的地址是：" << (void*) &girl.c << endl;

	girl.a = 3;
	girl.b = 8.8;
	strcpy(girl.c, "我是一只傻傻鸟。");
	cout << "girl.a=" << girl.a << endl;
	cout << "girl.b=" << girl.b << endl;
	cout << "girl.c=" << girl.c << endl;
}
```

## 枚举

枚举的语法：

```
enum 枚举名 { 枚举量1 , 枚举量2 , 枚举量3, ......, 枚举量n };
```

```
enum colors { red , yellow , blue };
```

这条语句完成了两项工作：

- 让colors成了一种新的枚举类型的名称，可以用它创建枚举变量。

- 将red、yellow、blue作为符号常量，默认值是整数的0、1、2。

注意：

- 用枚举创建的变量取值只能在枚举量范围之内。

- 枚举的作用域与变量的作用域相同。

- 可以显式的设置枚举量的值（必须是整数）。

```
enum colors {red=1,yellow=2,blue=3};
```

-  可以只显式的指定某些枚举量的值（枚举量的值可以重复）。
- 可以将整数强制转换成枚举量，语法：枚举类型(整数)

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	enum colors { red=0, yellow=1, blue=2, other=3 };    // 创建枚举类型colors。

	colors cc = yellow;           // 创建枚举变量，并赋初始值。
	//colors cc = colors(1);           // 创建枚举变量，并赋初始值。
	
	cout << "red=" << red << ",yellow=" << yellow << ",blue=" << blue << ",other=" << other << endl;

	switch (cc)
	{
		case red:			cout << "红色。\n"; break;
		case yellow:	cout << "黄色。\n"; break;
		case blue:		cout << "蓝色。\n"; break;
		default:			cout << "未知。\n"; 
	}
}
```

## 引用的基本概念

引用变量是C++新增的复合类型。

引用是已定义的变量的别名。

引用的主要用途是用作函数的形参和返回值。

声明/创建引用的语法：数据类型 &引用名=原变量名;

注意：

- 引用的数据类型要与原变量名的数据类型相同。

- 引用名和原变量名可以互换，它们值和内存单元是相同的。

- 必须在声明引用的时候初始化，初始化后不可改变。

- C和C++用&符号来指示/取变量的地址，C++给&符号赋予了另一种含义。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	// 声明 / 创建引用的语法：数据类型 & 引用名 = 原变量名;
	int a = 3;          // 声明普通的整型变量。
	int& ra = a;      // 创建引用ra，ra是a的别名。
	
	cout << " a的地址是：" << &a  << "， a的值是：" <<  a  << endl;
	cout << "ra的地址是：" << &ra << "，ra的值是：" << ra << endl;
	
	ra = 5;    

	cout << " a的地址是：" << &a << "， a的值是：" << a << endl;
	cout << "ra的地址是：" << &ra << "，ra的值是：" << ra << endl;
}
```

## 引用的本质

引用是指针常量的伪装。

​		引用是编译器提供的一个有用且安全的工具，去除了指针的一些缺点，禁止了部分不安全的操作。

 		变量是什么？变量就是一个在程序执行过程中可以改变的量。换一个角度，变量是一块内存区域的名字，它代表了这块内存区域，当我们对变量进行修改的时候，会引起内存区域中内容的改变。

​		在计算机看来，内存区域根本就不存在什么名字，它仅有的标志就是它的地址，因此我们若想修改一块内存区域的内容，只有知道他的地址才能实现。

​		所谓的变量只不过是编译器给我们进行的一种抽象，让我们不必去了解更多的细节，降低我们的思维跨度而已。

​		程序员拥有引用，但编译器仅拥有指针（地址）。

- 引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，编译器还是会把引用解释为指针。

- 引用和指针本质上没有区别。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

int main()
{
	// 声明 / 创建引用的语法：数据类型 & 引用名 = 原变量名;
	// 语法：数据类型 * const 变量名;
	int a = 3;                         // 声明普通的整型变量。
	int& ra = a;                    // 创建引用ra，ra是a的别名。               把int&替换成int* const   把a替换成&a
	int* const rb = &a;        // 声明指针常量rb，让它指向变量a。
	
	cout << " a的地址是：" << &a  << "，  a的值是：" <<  a  << endl;
	cout << "ra的地址是：" << &ra << "， ra的值是：" << ra << endl;     // 把&ra替换成ra，把ra替换成*ra
	cout << "rb的值是  ：" << rb << "，*rb的值是：" << *rb << endl;
	
	ra = 5;    

	cout << " a的地址是：" << &a << "，  a的值是：" << a << endl;
	cout << "ra的地址是：" << &ra << "， ra的值是：" << ra << endl;
	cout << "rb的值是  ：" << rb << "，*rb的值是：" << *rb << endl;
}
```

## 引用用于函数的参数

把函数的形参声明为引用，调用函数的时候，形参将成为实参的别名。

这种方法也叫按引用传递或传引用。（传值、传地址、传引用只是说法不同，其实都是传值。）

引用的本质是指针，传递的是变量的地址，在函数中，修改形参会影响实参。

1）传引用的代码更简洁。

2）传引用不必使用二级指针。

3）引用的属性和特别之处。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func1(int no, string str)    // 传值。
{
	no = 8; 
	str = "我有一只小小鸟。";
	cout << "亲爱的" << no << "号：" << str << endl;
}

void func2(int* no, string* str)    // 传地址。
{
	*no = 8;
	*str = "我有一只小小鸟。";
	cout << "亲爱的" << *no << "号：" << *str << endl;
}

void func3(int &no, string &str)    // 传引用。
{
	no = 8;
	str = "我有一只小小鸟。";
	cout << "亲爱的" << no << "号：" << str << endl;
}

int main()
{
	int bh = 3;      // 女孩的编号。
	string message = "我是一只傻傻鸟。";          // 向女孩表白的内容。

	//func1(bh, message);                  // 传值。
	//func2(&bh, &message);            // 传地址。
	func3(bh, message);                  // 传引用。
	
	cout << "亲爱的" << bh << "号：" << message << endl;
}


#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

struct st_girl      // 定义女孩结构体。
{
	int no;            // 女孩编号。
	string str;      // 表白内容。
};

void func1(st_girl girl)    // 传值。
{
	girl.no = 8;
	girl.str = "我有一只小小鸟。";
	cout << "亲爱的" << girl.no << "号：" << girl.str << endl;
}

void func2(st_girl *girl)    // 传地址。
{
	girl->no = 8;
	girl->str = "我有一只小小鸟。";
	cout << "亲爱的" << girl->no << "号：" << girl->str << endl;
}

void func3(st_girl & girl)    // 传引用。
{
	girl.no = 8;
	girl.str = "我有一只小小鸟。";
	cout << "亲爱的" << girl.no << "号：" << girl.str << endl;
}

int main()
{
	st_girl girl = { 3,"我是一只傻傻鸟。" };

	func1(girl);                  // 传值。
	//func2(&girl);            // 传地址。
	//func3(girl);                  // 传引用。
	
	cout << "亲爱的" << girl.no << "号：" << girl.str << endl;
}



#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func1(int** p)      // 传地址，实参是指针的地址，形参是二级指针。
{
	*p = new int(3);       // p是二级指针，存放指针的地址。
	cout << "func1内存的地址是：" << *p << "，内存中的值是：" << **p << endl;
}

void func2(int*& p)     // 传引用，实参是指针，形参是指针的别名。
{
	p = new int(3);         // p是指针的别名。
	cout << "func2内存的地址是：" << p << "，内存中的值是：" << *p << endl;
}

int main()
{
	int* p = nullptr;    // 存放在子函数中动态分配内存的地址。

	func1(&p);      // 传地址，实参填指针p的地址。
	//func2(p);      // 传引用，实参填指针p。

	cout << "main 内存的地址是：" << p << "，内存中的值是：" << *p << endl;

	delete p;
}
```

## 引用的形参和const

如果引用的数据对象类型不匹配，当引用为const时，C++将创建临时变量，让引用指向临时变量。

什么时候将创建临时变量呢？

- 引用是const。

- 数据对象的类型是正确的，但不是左值。

- 数据对象的类型不正确，但可以转换为正确的类型。

结论：如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量。

**将引用形参声明为const的理由有三个：**

- 使用const可以避免无意中修改数据的编程错误。

- 使用const使函数能够处理const和非const实参，否则将只能接受非const实参。

- 使用const，函数能正确生成并使用临时变量。

**左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针。**

**非左值包括字面常量（用双引号包含的字符串除外）和包含多项的表达式。**

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func1(int no, string str)    // 传值。
{
	cout << "亲爱的" << no << "号：" << str << endl;
}

void func2(const int* no,const string* str)    // 传地址。
{
	cout << "亲爱的" << *no << "号：" << *str << endl;
}

void func3(const int& no, const string& str)    // 传引用。
{
	cout << "亲爱的" << no << "号：" << str << endl;
}

int main()
{
	//int bh = 3;      // 女孩的编号。
	//string message = "我是一只傻傻鸟。";          // 向女孩表白的内容。
	//
	func1(8, "我是一只小小鸟。");
	// func2(8, "我是一只小小鸟。");
	func3('X', "我是一只小小鸟。");
	////func1(bh, message);                  // 传值。
	////func2(&bh, &message);            // 传地址。
	////func3(bh, message);                  // 传引用。

	//cout << "亲爱的" << bh << "号：" << message << endl;
}
```

## 引用用于函数的返回值

传统的函数返回机制与值传递类似。

函数的返回值被拷贝到一个临时位置（寄存器或栈），然后调用者程序再使用这个值。

```
double m=sqrt(36);   // sqrt()是求平方根函数。
```

sqrt(36)的返回值6被拷贝到临时的位置，然后赋值给m。

```
cout << sqrt(25);
```

sqrt(25)的返回值5被拷贝到临时的位置，然后传递给cout。

如果返回的是一个结构体，将把整个结构体拷贝到临时的位置。

如果返回引用不会拷贝内存。

语法：

```
返回值的数据类型& 函数名(形参列表);
```

注意：

- 如果返回局部变量的引用，其本质是野指针，后果不可预知。

- 可以返回函数的引用形参、类的成员、全局变量、静态变量。

- 返回引用的**函数是**被引用的变量的**别名**，将const用于引用的返回类型。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

const int &func2(int &ra)    // 返回的是引用。
{
	ra++;
	cout << "ra的地址是：" << &ra << "，ra=" << ra << endl;
	return ra;
}

int main()
{
	int a = 3;
	const int& b = func2(a);      // 返回的是引用。

	cout << " a的地址是：" << &a << "， a=" << a << endl;
	cout << " b的地址是：" << &b << "， b=" << b << endl;

	// func2(a) = 10;             // 返回引有的函数是被引用的变量的别名。

	// cout << " a的地址是：" << &a << "， a=" << a << endl;
	// cout << " b的地址是：" << &b << "， b=" << b << endl;
}
```

## 各种形参的使用场景

传值、传地址和传引用的指导原则《C++ Primer Plus》

**1**）如果不需要在函数中修改实参

- 如果实参很小，如C++内置的数据类型或小型结构体，则按值传递。

- 如果实参是数组，则使用const指针，因为这是唯一的选择（没有为数组建立引用的说法）。

- 如果实参是较大的结构，则使用const指针或const引用。

- 如果实参是类，则使用const引用，传递类的标准方式是按引用传递（类设计的语义经常要求使用引用）。

**2**）如果需要在函数中修改实参

- 如果实参是内置数据类型，则使用指针。只要看到func(&x)的调用，表示函数将修改x。

- 如果实参是数组，则只能使用指针。

- 如果实参是结构体，则使用指针或引用。

- 如果实参是类，则使用引用。

当然，这只是一些指导原则，很可能有充分的理由做出其他的选择。

例如：对于基本类型，cin使用引用，因此可以使用cin>>a，而不是cin>>&a。

## 函数的默认参数

默认参数是指调用函数的时候，如果不书写实参，那么将使用的一个缺省值。

语法：返回值 函数名(数据类型 参数=值, 数据类型 参数=值,……);

注意：

- 如果函数的声明和定义是分开书写的，在函数声明中书写默认参数，函数的定义中不能书写默认参数。

- 函数必须从右到左设置默认参数。也就是说，如果要为某个参数设置默认值，则必须为它后面所有的参数设置默认值。

调用函数的时候，如果指定了某个参数的值，那么该参数前面所有的参数都必须指定。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

void func(int bh,const string &name="西施", const string& message="我喜欢你。")    // 向女孩表白的函数。
{
	cout << "亲爱的"<<name<<"（"<<bh<<")：" << message << endl;
}

int main()
{
	func(3,"冰冰","我是一只傻傻鸟。"); 
	func(5);
}
```

## 函数重载

函数重载（函数多态）是指设计一系列同名函数，让它们完成相同（似）的工作。

C++允许定义名称相同的函数，条件是它们的特征（形参的个数、数据类型和排列顺序）不同。

```
#1	int func(short a  ,string b);
#2	int func(int a    ,string b);
#3	int func(double a,string b);
#4	int func(int a    ,string b, int len);
#5	int func(string b , int a);
```

调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。

在实际开发中，视需求重载各种数据类型，不要重载功能不同的函数。

注意：

- 使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错。

- 引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征。

- 如果重载函数有默认参数，调用函数时，可能导致匹配失败。

- const不能作为函数重载的特征。

- 返回值的数据类型不同不能作为函数重载的特征。

- C++的名称修饰：编译时，对每个函数名进行加密，替换成不同名的函数。

```
void MyFunctionFoo(int,float);
void MyFunctionFoo(long,float);
?MyFunctionFoo@@YAXH(int,float);
#void MyFunctionFoo^$@(long,float);
```

```
#include <iostream>         // 包含头文件。
using namespace std;

void myswap(int& a, int& b)     // 交换两个整型变量的值。
{
	int tmp = a; a = b; b = tmp;
}

void myswap(string& a, string& b)     // 交换两个字符串变量的值。
{
	string tmp = a; a = b; b = tmp;
}

int main()
{
	int a = 3, b = 5;
	myswap(a, b);
	cout << "a=" << a << ",b=" << b << endl;

	string c = "西施", d = "西瓜";
	myswap(c, d);
	cout << "c=" << c << ",d=" << d << endl;
}
```

## 内联函数

C++将内联函数的代码组合到程序中，可以提高程序运行的速度。

语法：在函数声明和定义前加上关键字inline。

通常的做法是将函数声明和定义写在一起。

注意：

- 内联函数节省时间，但消耗内存。

- 如果函数过大，编译器可能不将其作为内联函数。

-  内联函数不能递归。

```c++
#include <iostream>         // 包含头文件。
using namespace std;

inline void show(const short bh, const string message)   // 表白函数。
{
	cout << "亲爱的" << bh << "号：" << message << endl;
}

int main()
{
	//show(3, "我是一只傻傻鸟。");
	{
		int bh = 3;
		string message = "我是一只傻傻鸟。";
		cout << "亲爱的" << bh << "号：" << message << endl;
	}
	// show(8, "我有一只小小鸟。");
	{
		int bh = 8;
		string message = "我有一只小小鸟。";
		cout << "亲爱的" << bh << "号：" << message << endl;
	}
	// show(5, "我是一只小小鸟。");
	{
		int bh = 5;
		string message = "我是一只小小鸟。";
		cout << "亲爱的" << bh << "号：" << message << endl;
	}
}
```

## 从结构体到类

对面向对象编程来说，一切都是对象，对象用类来描述。

类把对象的数据和操作数据的方法作为一个整体考虑。

定义类的语法：

```
class 类名
{
public:
成员一的数据类型  成员名一;
成员二的数据类型  成员名二;
成员三的数据类型  成员名三;
......
成员n的数据类型  成员名n;
};
```

注意：

- 类的成员可以是变量，也可以是函数。

- 类的成员变量也叫属性。

- 类的成员函数也叫方法/行为，类的成员函数可以定义在类的外面。

- 用类定义一个类的变量叫创建（或实例化）一个对象。

- 对象的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

struct st_girl                 // 女孩基本信息结构体st_girl，存放了女孩全部的数据项。
{
    string    name;          // 姓名。
    int         age;             // 年龄。
    int         height;        // 身高（cm）。
    double weight;        // 体重（kg）。
    char      sex='X';       // 性别：X-女；Y-男。
    int         yz;               // 颜值：1-漂亮；2-一般；3-歪瓜裂枣。
    string    special;       // 特长。
    string    memo;        // 备注。
};

void setvalue(st_girl& girl, string name, int age, int height, double weight,
    char sex, int yz, string special, string memo)
{
    girl.name = name;
    girl.age = age;
    girl.height = height;
    girl.weight = weight;
    girl.sex = sex;
    girl.yz = yz;
    girl.special = special;
    girl.memo = memo;
}

void show(const st_girl& girl)
{
    cout << "姓名：" << girl.name << "，年龄：" << girl.age << "，身高：" << girl.height
        << "，体重：" << girl.weight << "，性别：" << girl.sex << "，颜值：" << girl.yz
        << "，特长：" << girl.special << "，备注：" << girl.memo << endl;
}

int main()
{
    st_girl girl;

    setvalue(girl, "西施", 26, 170, 50.5, 'X', 1, "唱歌、跳舞、洗衣服。", "春秋第一美女，四大美女之一。");
    
    show(girl);
}


#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

struct st_girl                 // 女孩基本信息结构体st_girl，存放了女孩全部的数据项。
{
    string    name;          // 姓名。
    int         age;             // 年龄。
    void setvalue(string name1, int age1)    // 设置成员变量的值。
    {
        name = name1;     age = age1;
    }
    void show()    // 显示女孩的自我介绍。
    {
        cout << "姓名：" << name << "，年龄：" << age << endl;
    }
};

int main()
{
    st_girl girl;     // 创建结构体变量。
    girl.setvalue("西施", 26);     // 设置成员变量的值。
    girl.show();    // 显示女孩的自我介绍。
}
```

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl                 // 女孩类CGirl。
{
public:
    string    name;          // 姓名。
    int         age;             // 年龄。
    void setvalue(string name1, int age1);    // 设置成员变量的值。
    void show()    // 显示女孩的自我介绍。
    {
        cout << "姓名：" << name << "，年龄：" << age << endl;
    }
};

void CGirl::setvalue(string name1, int age1)    // 设置成员变量的值。
{
    name = name1;     age = age1;
}

int main()
{
    CGirl girl;       // 创建女孩对象。
    girl.setvalue("西施", 26);     // 设置成员变量的值。
    girl.show();    // 显示女孩的自我介绍。
}
```

## 类的访问权限

类的成员有三种访问权限：public、private和protected，分别表示公有的、私有的和受保护的。

在类的内部（类的成员函数中），无论成员被声明为 public还是private，都可以访问。

在类的外部（定义类的代码之外），只能访问public成员，不能访问 private、protected成员。

在一个类体的定义中，private 和 public 可以出现多次。

结构体的成员缺省为public，类的成员缺省为private。

private的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为public。

## 简单使用类

编程思想和方法的改变，披着C++外衣的C程序员。

1）类的成员函数可以直接访问该类其它的成员函数（可以递归）。

2）类的成员函数可以重载，可以使用默认参数。

3）类指针的用法与结构体指针用法相同。

4）类的成员可以是任意数据类型（类中枚举）。

5）可以为类的成员指定缺省值（C++11标准）。

6）类可以创建对象数组，就像结构体数组一样。

7）对象可以作为实参传递给函数，一般传引用。

8）可以用new动态创建对象，用delete释放对象。

9）在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。

10）对象一般不用memset()清空成员变量，可以写一个专用于清空成员变量的成员函数。

11）对类和对象用sizeof运算意义不大，一般不用。

12）用结构体描述纯粹的数据，用类描述对象。

13）在类的声明中定义的函数都将自动成为内联函数；在类的声明之外定义的函数如果使用了inline限定符，也是内联函数。

14）为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。

15）类的分文件编写。

## 构造函数和析构函数

**构造函数：**在创建对象时，自动的进行初始化工作。

**析构函数：**在销毁对象前，自动的完成清理工作。

**1**）构造函数

语法：类名(){......}

- 访问权限必须是public。

- 函数名必须与类名相同。

- 没有返回值，不写void。

- 可以有参数，可以重载，可以有默认参数。

- 创建对象时只会自动调用一次，不能手工调用。

**2**）析构函数

语法：~类名(){......}

- 访问权限必须是public。

- 函数名必须在类名前加~。

- 没有返回值，也不写void。

- 没有参数，不能重载。

- 销毁对象前只会自动调用一次，但是可以手工调用。

注意：

1） 如果没有提供构造/析构函数，编译器将提供空实现的构造/析构函数。

2） 如果提供了构造/析构函数，编译器将不提供空实现的构造/析构函数。

3） 创建对象的时候，如果重载了构造函数，编译器根据实参匹配相应的构造函数。没有参数的构造函数也叫默认构造函数。

4） 创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（如果没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）

**5）** **在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。**

6） 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐）。

```
CGirl girl =10;
```

7） 以下两行代码有本质的区别：

```
CGirl girl = CGirl("西施"20);  // 显式创建对象。
CGirl girl;                   // 创建对象。
girl = CGirl("西施"20);        // 创建匿名对象，然后给现有的对象赋值。
```

8） 用new/delete创建/销毁对象时，也会调用构造/析构函数。

9） 不建议在构造/析构函数中写太多的代码，可以调用成员函数。

10） 除了初始化，不建议让构造函数做太多工作（只能成功不会失败）。

11） C++11支持使用统一初始化列表。

```
CGirl girl = {"西施"20};
CGirl girl  {"西施"20};
CGirl* girl = new CGirl{ "西施"20 };
```

12 ) 如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构自身，再析构成员类。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl                 // 女孩类CGirl。
{
public:
    string    m_name;                                  // 姓名属性。
    int         m_age;                                     // 年龄属性。
    char      m_memo[301];                        // 备注。
    CGirl()                                        // 没有参数的构造函数。  
    {
        initdata();
        cout << "调用了CGirl()构造函数。\n";
    }
    CGirl(string name)                   // 一个参数（姓名）的构造函数。
    {
        initdata();
        cout << "调用了CGirl(name)构造函数。\n";
        m_name = name;
    }
    CGirl(int age)                           // 一个参数（年龄）的构造函数。
    {
        initdata();
        cout << "调用了CGirl(age)构造函数。\n";
        m_age = age;
    }
    CGirl(string name, int age)      // 两个参数的构造函数。
    {
        initdata();
        cout << "调用了CGirl(name,age)构造函数。\n";
        m_name = name; m_age = age;
    }
    void initdata()
    {
        m_name.clear(); m_age = 0; memset(m_memo, 0, sizeof(m_memo));
    }
    ~CGirl()                                     // 析构函数。  
    {
        cout << "调用了~CGirl()\n";
    }
    void show()                               // 女孩自我介绍的方法。
    {  cout << "姓名：" << m_name << "，年龄：" << m_age << "，备注：" << m_memo<< endl; }
};

int main()
{
    // CGirl girl;                     // 创建女孩对象，不设置任何初始值。
    // CGirl girl("西施");        // 创建女孩对象，为成员姓名设置初始值。
    // CGirl girl("西施",8);     // 创建女孩对象，为成员姓名和年龄设置初始值。
    // CGirl girl=CGirl();                   // 创建女孩对象，不设置任何初始值。
    // CGirl girl=CGirl("西施");        // 创建女孩对象，为成员姓名设置初始值。
    // CGirl girl=CGirl("西施",8);     // 创建女孩对象，为成员姓名和年龄设置初始值。
    // CGirl girl = 8;                         // 使用赋值语法初始化对象。
    // CGirl *girl=new CGirl;                   // 创建女孩对象，不设置任何初始值。
    // CGirl *girl=new CGirl("西施");        // 创建女孩对象，为成员姓名设置初始值。
    CGirl *girl=new CGirl("西施",8);     // 创建女孩对象，为成员姓名和年龄设置初始值。
    
    girl->show();    // 显示女孩的自我介绍。
    delete girl;
}
```

## 拷贝构造函数

用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。

如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。

用一个已存在的对象创建新的对象语法：

```
类名 新对象名(已存在的对象名);
类名 新对象名=已存在的对象名;
```

拷贝构造函数的语法：

```
类名(const 类名& 对象名){......}
```

注意：

- 访问权限必须是public。

- 函数名必须与类名相同。

- 没有返回值，不写void。

- 如果类中定义了拷贝构造函数，编译器将不提供默认的拷贝构造函数。

- 以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。

- **函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用，Linux不会，g++编译器做了优化）。**

拷贝构造函数可以重载，可以有默认参数。

```
类名(......,const 类名& 对象名,......){......}
```

- 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl                 // 超女类CGirl。
{
public:
    string    m_name;                                  // 姓名属性。
    int         m_age;                                     // 年龄属性。
    
    // 没有参数的普通构造函数。  
    CGirl() { m_name.clear(); m_age = 0;  cout << "调用了CGirl()构造函数。\n"; }

    // 没有重载的拷贝构造函数（默认拷贝构造函数）。  
    CGirl(const CGirl &gg) { m_name="漂亮的"+gg.m_name; m_age = gg.m_age-1;  cout << "调用了CGirl(const CGirl &gg)拷贝构造函数。\n"; }

    // 重载的拷贝构造函数。  
    CGirl(const CGirl& gg,int ii) { m_name = "漂亮的" + gg.m_name; m_age = gg.m_age - ii;  cout << "调用了CGirl(const CGirl &gg,int ii)拷贝构造函数。\n"; }

    // 析构函数。  
    ~CGirl() { cout << "调用了~CGirl()\n"; }

    // 超女自我介绍的方法，显示姓名和年龄。
    void show() { cout << "姓名：" << m_name << "，年龄：" << m_age << endl; }
};

int main()
{
    CGirl g1;
    g1.m_name = "西施"; g1.m_age = 23;
    CGirl g2(g1,3);
    g2.show();
}
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl                 // 超女类CGirl。
{
public:
    string    m_name;                                  // 姓名属性。
    int         m_age;                                     // 年龄属性。
    int*       m_ptr;                                       // 指针成员，计划使用堆内存。

    // 没有参数的普通构造函数。  
    CGirl() { m_name.clear(); m_age = 0;  m_ptr = nullptr;  cout << "调用了CGirl()构造函数。\n"; }

    // 没有重载的拷贝构造函数（默认拷贝构造函数）。  
    CGirl(const CGirl& gg) 
    { 
        m_name = gg.m_name; m_age = gg.m_age;  
        m_ptr = new int;         // 分配内存。
        // *m_ptr = *gg.m_ptr;   // 拷贝数据。
        memcpy(m_ptr, gg.m_ptr, sizeof(int));   // 拷贝数据。
        cout << "调用了CGirl(const CGirl &gg)拷贝构造函数。\n"; 
    }

    // 析构函数。  
    ~CGirl() { delete m_ptr; m_ptr = nullptr; cout << "调用了~CGirl()\n";  }

    // 超女自我介绍的方法，显示姓名和年龄。
    void show() { cout << "姓名：" << m_name << "，年龄：" << m_age << "，m_ptr="<< m_ptr<<"，*m_ptr="<<*m_ptr<<endl; }
};

int main()
{
    CGirl g1;
    g1.m_name = "西施"; g1.m_age = 23; g1.m_ptr = new int(3);
    g1.show();

    CGirl g2(g1);  *g2.m_ptr = 8;
    g1.show();
    g2.show();
}
```

## 初始化列表

构造函数的执行可以分成两个阶段：初始化阶段和计算阶段（初始化阶段先于计算阶段）。

- 初始化阶段：全部的成员都会在初始化阶段初始化。

- 计算阶段：一般是指用于执行构造函数体内的赋值操作。

构造函数除了参数列表和函数体之外，还可以有初始化列表。

初始化列表的语法：

```
类名(形参列表):成员一(值一), 成员二(值二),..., 成员n(值n)
{......}
```

注意：

1）如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。

2）初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。

**3****）初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再赋值。**

4）如果成员是类，初始化列表对性能略有提升。

**5****）如果成员是常量和引用，必须使用初始列表，因为常量和引用只能在定义的时候初始化。**

6）如果成员是没有默认构造函数的类，则必须使用初始化列表。

7）拷贝构造函数也可以有初始化列表。

8）类的成员变量可以不出现在初始化列表中。

9）构造函数的形参先于成员变量初始化。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CBoy                // 男朋友类。
{
public:
    string m_xm;                      // 男朋友的姓名。
    CBoy()                                 // 没有参数的普通构造函数，默认构造函数。  
    { m_xm.clear();  cout << "调用了CBoy()构造函数。\n"; }
    CBoy(string xm)                 // 有一个参数的普通构造函数。  
    { m_xm = xm;  cout << "调用了CBoy(string xm)构造函数。\n"; }
    CBoy(const CBoy& bb)     // 默认拷贝构造函数。  
    { m_xm = bb.m_xm;  cout << "调用了CBoy(const CBoy &bb)拷贝构造函数。\n"; }
};

class CGirl                 // 超女类CGirl。
{
public:
    string    m_name;                     // 姓名属性。
    const int         m_age;                         // 年龄属性。
    CBoy&     m_boy;                         // 男朋友的信息。
    //CGirl()                                       // 没有参数的普通构造函数，默认构造函数。  
    //{  
    //    cout << "调用了CGirl()构造函数。\n"; 
    //}
    //CGirl(string name, int age,CBoy &boy)     // 三个参数的普通构造函数。
    //{
    //    m_name = name; m_age = age; m_boy.m_xm = boy.m_xm;
    //    cout << "调用了CGirl(name,age,boy)构造函数。\n";
    //}
    CGirl(string name, int age, CBoy& boy) :m_name(name), m_age(age),m_boy(boy)      // 三个参数的普通构造函数。
    {
        cout << "调用了CGirl(name,age,boy)构造函数。\n";
    }
    // 超女自我介绍的方法，显示姓名、年龄、男朋友。
    void show() { cout << "姓名：" << m_name << "，年龄：" << m_age << "，男朋友：" << m_boy.m_xm << endl; }
};

int main()
{
    CBoy boy("子都");

    CGirl g1("冰冰",18,boy);
    
    g1.show();
}
```

## const修饰成员函数

在类的成员函数后面加const关键字，表示在成员函数中保证不会修改调用对象的成员变量。

注意：

1）mutable可以突破const的限制，被mutable修饰的成员变量，将永远处于可变的状态，在const修饰的函数中，mutable成员也可以被修改。

2）非const成员函数可以调用const成员函数和非const成员函数。

3）const成员函数不能调用非const成员函数。

4）非const对象可以调用const修饰的成员函数和非const修饰的成员函数。

5）const对象只能调用const修饰的成员函数，不能调用非cosnt修饰的成员函数。

这里出现了令人纠结的三个问题：

1、为什么要保护类的成员变量不被修改？

2、为什么用const保护了成员变量，还要再定义一个mutable关键字来突破const的封锁线？

3、到底有没有必要使用const和mutable这两个关键字？

​		保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，通过用const关键字来避免在函数中错误的修改了类对象的状态。并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。而mutable则是为了能突破const的封锁线，让类的一些次要的或者是辅助性的成员变量随时可以被更改。没有使用const和mutable关键字当然没有错，const和mutable 关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl                 // 超女类CGirl。
{
public:
    mutable string    m_name;                     // 姓名属性。
    int         m_age;                         // 年龄属性。

    // 两个参数的普通构造函数。
    CGirl(const string &name, int age) 
    { m_name = name; m_age = age;  cout << "调用了CGirl(name,age)构造函数。\n"; }
    
    // 超女自我介绍的方法，显示姓名、年龄。
    void show1() const
    { 
        m_name="西施show1";
        cout << "姓名：" << m_name << "，年龄：" << m_age << endl; 
    }
    void show2() const
    {
        m_name = "西施show2";
        cout << "姓名：" << m_name << "，年龄：" << m_age << endl;
    }
    void show3() 
    {
        m_name = "西施show3";
        cout << "姓名：" << m_name << "，年龄：" << m_age << endl;
    }
    void show4() 
    {
        m_name = "西施show4";
        cout << "姓名：" << m_name << "，年龄：" << m_age << endl;
    }
};

int main()
{
    const CGirl g1("冰冰",18);
    
    g1.show1();
}
```

## this指针

如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。

this指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。

每个成员函数（包括构造函数和析构函数）都有一个this指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）

*this可以表示对象。

如果在成员函数的括号后面使用const，那么将不能通过this指针修改成员变量。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl                 // 超女类CGirl。
{
public:
    string    m_name;                    // 姓名属性。
    int         m_yz;                          // 颜值：1-沉鱼落雁；2-漂亮；3-一般；4-歪瓜裂枣。

    // 两个参数的普通构造函数。
    CGirl(const string &name, int yz)  { m_name = name; m_yz = yz;  }
    
    // 超女自我介绍的方法。
    void show() const  { cout << "我是：" << m_name << "，最漂亮的超女。"<< endl; }

    // 超女颜值pk的方法。
    const CGirl& pk(const CGirl& g) const
    {
        if (g.m_yz < m_yz) return g;
        return *this;
    }
};
int main()
{
    // 比较五个超女的颜值，然后由更漂亮的超女作自我介绍。
    CGirl g1("西施",5), g2("西瓜",3), g3("冰冰", 4), g4("幂幂", 5), g5("金莲", 2);
    const CGirl& g = g1.pk(g2).pk(g3).pk(g4).pk(g5);
    g.show();
}
```

## 静态成员

类的静态成员包括静态成员变量和静态成员函数。

用静态成员可以变量实现多个对象之间的数据共享，比全局变量更安全性。

用 static 关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。

静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解析运算符 ::）。

静态成员使用类名加范围解析运算符 :: 就可以访问，不需要创建对象。

**如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）。**

静态成员变量在程序中只有一份（生命周期与程序运行期相同，存放在静态存储区的），不论是否创建了类的对象，也不论创建了多少个类的对象。

在静态成员函数中，只能访问静态成员，不能访问非静态成员。

静态成员函数中没有this指针。

在非静态成员函数中，可以访问静态成员。

**私有静态成员在类外无法访问。**

const静态成员变量可以在定义类的时候初始化。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl                 // 超女类CGirl。
{
    static int m_age;                        // 年龄属性。
public:
    string      m_name;                    // 姓名属性。

    // 两个参数的普通构造函数。
    CGirl(const string& name, int age) { m_name = name; m_age = age; }
    // 显示超女的姓名。
    void showname()  { cout << "姓名：" << m_name << endl; }
    // 显示超女的年龄。
    static void showage() { cout << "年龄：" << m_age << endl; }
};

int CGirl::m_age=8;        // 初始化类的静态成员变量。

int main()
{
    CGirl g1("西施1", 21), g2("西施2", 22), g3("西施3", 23);

    g1.showname(); g1.showage();
    g2.showname(); g2.showage();
    g3.showname(); g3.showage();

    CGirl::showage();
    // cout << "CGirl::m_age=" << CGirl::m_age << endl;
}
```

## 简单对象模型

在C语言中，**数据**和**处理数据的操作（函数）**是分开的。也就是说，C语言本身没有支持**数据和函数**之间的关联性。

C++用类描述抽象数据类型（abstract data type，ADT），在类中定义了**数据**和**函数**，把**数据**和**函数**关联起来。

对象中维护了多个指针表，表中放了成员与地址的对应关系。

```c++
class CGirl       // 超女类CGirl。
{
public:
    char    m_name[10];              // 姓名属性。
    int      m_age;                   // 年龄属性。
    // 默认构造函数和析构函数。
    CGirl() { memset(m_name, 0, sizeof(m_name)); m_age = 0;  }
    ~CGirl() {  }
    // 显示超女的姓名。
    void showname() { cout << "姓名：" << m_name << endl; }
    // 显示超女的年龄。
    void showage() { cout << "年龄：" << m_age << endl; }
};
```

![image-20230928165603257](./photo/image-20230928165603257-1695896015069-11.png)

C++类中有两种数据成员：nonstatic、static，三种函数成员：nonstatic、static、virtual。

- 对象内存的大小包括：1）所有非静态数据成员的大小；2）由内存对齐而填补的内存大小；3）为了支持virtual成员而产生的额外负担。

- 静态成员变量属于类，不计算在对象的大小之内。

- 成员函数是分开存储的，不论对象是否存在都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内。

- 用空指针可以调用没有用到this指针的非静态成员函数。

- 对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl       // 超女类CGirl。
{
public:
    char    m_name[3];              // 姓名属性。
    int       m_bh;                        // 编号属性。
    static int       m_age;                      // 年龄属性。

    // 默认构造函数和析构函数。
    CGirl() { memset(m_name, 0, sizeof(m_name)); m_age = 0;  }
    ~CGirl() {  }
    // 显示超女的姓名。
    void showname() { if (this == nullptr) return;  cout << "姓名：" << this->m_name << endl; }
    // 显示超女的年龄。
    void showage() { cout << "年龄：" << m_age << endl; }
};

int CGirl::m_age;
int aaa;
void func() {}

int main()
{
    CGirl g;
    cout << "对象g占用的内存大小是：" << sizeof(g) << endl;
    cout << "对象g的地址是：" << (void*)&g << endl;
    cout << "成员变量m_bh的地址是：" << (void*)&g.m_bh << endl;
    cout << "成员变量m_name的地址是：" << (void*)&g.m_name << endl;
    cout << "成员变量m_age的地址是：" << (void *)&g.m_age << endl;
    cout << "全局变量aaa的地址是：" << (void*)&aaa << endl;
    printf("成员函数showname的地址是：%p\n", &CGirl::showname);
    printf("成员函数showage的地址是：%p\n", &CGirl::showage);
    printf("函数func()的地址是：%p\n", func);

    CGirl* g1 = nullptr;
    g1->showname();
}
```

## 友元

如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。

友元提供了另一访问类的私有成员的方案。友元有三种：

- 友元全局函数。

- 友元类。

- 友元成员函数。

**1**）友元全局函数

 在友元全局函数中，可以访问另一个类的所有成员。

**2**）友元类

在友元类所有成员函数中，都可以访问另一个类的所有成员。

友元类的注意事项：

- 友元关系不能被继承。

- 友元关系是单向的，不具备交换性。

若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。

**3**）友元成员函数

在友元成员函数中，可以访问另一个类的所有成员。

如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：

```
class CGirl;            // 前置声明。   
class CBoy { ...... };      // CBoy的定义。
class CGirl { ...... };      // CGirl的定义。
                                      
// 友元成员函数的定义。               
void CBoy::func(CGirl &g) { ...... }       
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl       // 超女类CGirl。
{
    friend int main();
    friend void func();
public:
    string    m_name;   // 姓名。
    // 默认构造函数。
    CGirl() { m_name = "西施";  m_xw = 87; }
    // 显示姓名的成员函数。
    void showname() { cout << "姓名：" << m_name << endl; }
private:
    int         m_xw;        // 胸围。
    // 显示胸围的成员函数。
    void showxw() { cout << "胸围：" << m_xw << endl; }
};

void func()
{
    CGirl g;
    g.showname();
    g.showxw();
}

int main()
{
    func();
}

///////////////////////////////////////////////////////////////////////////////////////
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl       // 超女类CGirl。
{
    friend class CBoy;
public:
    string    m_name;   // 姓名。
    // 默认构造函数。
    CGirl() { m_name = "西施";  m_xw = 87; }
    // 显示姓名的成员函数。
    void showname() { cout << "姓名：" << m_name << endl; }
private:
    int         m_xw;        // 胸围。
    // 显示胸围的成员函数。
    void showxw() const { cout << "胸围：" << m_xw << endl; }
};

class CBoy    // 超女的男朋友类
{
public:
    void func(const CGirl& g)
    {
        cout << "我女朋友的姓名是：" << g.m_name << endl;
        cout << "我女朋友的胸围是：" << g.m_xw << endl;
        g.showxw();
    }
};
```

```
int main()
{
    CGirl g;
    CBoy b;
    b.func(g);
}

///////////////////////////////////////////////////////////////////////////////////////

#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl;      // 把超女类的声明前置

class CBoy    // 超女的男朋友类
{
public:
    void func1(const CGirl& g);
    void func2(const CGirl& g);
};

class CGirl       // 超女类CGirl。
{
    friend void CBoy::func1(const CGirl& g);
    // friend void CBoy::func2(const CGirl& g);
public:
    string    m_name;   // 姓名。
    // 默认构造函数。
    CGirl() { m_name = "西施";  m_xw = 87; }
    // 显示姓名的成员函数。
    void showname() { cout << "姓名：" << m_name << endl; }
private:
    int         m_xw;        // 胸围。
    // 显示胸围的成员函数。
    void showxw() const { cout << "胸围：" << m_xw << endl; }
};

void CBoy::func1(const CGirl& g) { cout << "func1()我女朋友的胸围是：" << g.m_xw << endl; }
void CBoy::func2(const CGirl& g) { cout << "func2()我女朋友的姓名是：" << g.m_name << endl; }

int main()
{
    CGirl g;
    CBoy b;
    b.func2(g);
    b.func1(g);
}
```

## 运算符重载基础

C++将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观。

例如字符串string用加号（+）拼接、cout用两个左尖括号（<<）输出。

运算符重载函数的语法：返回值 operator运算符(参数列表);

运算符重载函数的返回值类型要与运算符本身的含义一致。

非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；

成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递了调用对象。

如果同时重载了非成员函数和成员函数版本，会出现二义性。

**注意：**

1）返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）

2）重载函数参数列表中的顺序决定了操作数的位置。

3）重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符。

4）如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷。

5）重载函数不能违背运算符原来的含义和优先级。

6）不能创建新的运算符。

7）以下运算符不可重载：

```
sizeof             sizeof运算符
.                  成员运算符
.*                 成员指针运算符
::                 作用域解析运算符
?:                 条件运算符
typeid            一个RTTI运算符
const_cast        强制类型转换运算符
dynamic_cast     强制类型转换运算符
reinterpret_cast   强制类型转换运算符
static_cast        强制类型转换运算符
```

8）以下运算符只能通过成员函数进行重载：

```
=                赋值运算符
()                函数调用运算符
[]                下标运算符
->               通过指针访问类成员的运算符
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl       // 超女类CGirl。
{
    friend CGirl &operator+(CGirl& g, int score);
    friend CGirl& operator+(int score, CGirl& g);
    friend CGirl& operator+(CGirl& g1, CGirl& g2);
private:
    int         m_xw;        // 胸围。
    int         m_score;    // 分数。
public:
    string    m_name;   // 姓名。

    // 默认构造函数。
    CGirl() { m_name = "西施";  m_xw = 87;  m_score = 30; }
    // 自我介绍的方法。
    void show() { cout << "姓名：" << m_name << "，胸围：" << m_xw << "，评分：" << m_score << endl; }

    //CGirl& operator-(int score)    // 给超女减分的函数。
    //{
    //    m_score = m_score - score;
    //    return *this;
    //}
};

CGirl& operator+(CGirl& g, int score)    // 给超女加分的函数。
{
    g.m_score = g.m_score + score;
    return g;
}
CGirl& operator+(int score,CGirl& g)    // 给超女加分的函数。
{
    g.m_score = g.m_score + score;
    return g;
}
CGirl& operator+(CGirl& g1, CGirl& g2)    // 给超女加分的函数。
{
    g1.m_score = g1.m_score + g2.m_score;
    return g1;
}

int main()
{
    // 导演的要求：每轮表演之后，给超女加上她的得分。
    CGirl g;
    g =  g+g;
    g.show();
}
```

## 重载关系运算符

重载关系运算符（==、!=、>、>=、<、<=）用于比较两个自定义数据类型的大小。

可以使用非成员函数和成员函数两种版本，建议采用成员函数版本。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl       // 超女类CGirl。
{
    string    m_name;     // 姓名。
    int         m_yz;           // 颜值：1-千年美人；2-百年美人；3-绝代美人；4-极漂亮；5-漂亮；6-一般；7-歪瓜裂枣。
    int         m_sc;           // 身材：1-火辣；2-...；3-...；4-...；5-...；6-...；7-膘肥体壮。
    int         m_acting;    // 演技：1-完美；2-...；3-...；4-...；5-...；6-...；7-四不像。
public:
    // 四个参数的构造函数。
    CGirl(string name, int yz, int sc, int acting) { m_name = name;  m_yz = yz;  m_sc = sc; m_acting = acting; }
    // 比较两个超女的商业价值。
    bool operator==(const CGirl& g1)      // 相等==
    {
        if ((m_yz + m_sc + m_acting) == (g1.m_yz + g1.m_sc + g1.m_acting)) return true;
        return false;
    }
    bool operator>(const CGirl& g1)      // 大于>
    {
        if ((m_yz + m_sc + m_acting) < (g1.m_yz + g1.m_sc + g1.m_acting)) return true;
        return false;
    }
    bool operator<(const CGirl& g1)      // 小于<
    {
        if ((m_yz + m_sc + m_acting) > (g1.m_yz + g1.m_sc + g1.m_acting)) return true;
        return false;
    }
};

int main()
{
    CGirl  g1("西施", 1, 2, 2), g2("冰冰", 1, 1, 1);
      
    if (g1==g2)
        cout << "西施和冰冰的商业价值相同。\n";
    else
        if (g1>g2)
            cout << "西施商业价值相同比冰冰大。\n";
        else
            cout << "冰冰商业价值相同比西施大。\n";
}
```

## 重载左移运算符

重载左移运算符（<<）用于输出自定义对象的成员变量，在实际开发中很有价值（调试和日志）。

只能使用非成员函数版本。

如果要输出对象的私有成员，可以配合友元一起使用。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl       // 超女类CGirl。
{
    friend ostream& operator<<(ostream& cout, const CGirl& g);
    string    m_name;   // 姓名。
    int         m_xw;        // 胸围。
    int         m_score;    // 评分。
public:
    // 默认构造函数。
    CGirl() { m_name = "西施";  m_xw = 87;  m_score = 30; }
    
    // 自我介绍的方法。
    void show() { cout << "姓名：" << m_name << "，胸围：" << m_xw << "，评分：" << m_score << endl; }
};

ostream& operator<<(ostream& cout, const CGirl& g)
{
    cout << "姓名：" << g.m_name << "，胸围：" << g.m_xw << "，评分：" << g.m_score;
    return cout;
}

int main()
{
    CGirl g;
    cout << g << endl;
}
```

##  重载下标运算符

如果对象中有数组，重载下标运算符[]，操作对象中的数组将像操作普通数组一样方便。

下标运算符必须以成员函数的形式进行重载。

下标运算符重载函数的语法：

```

返回值类型 &perator[](参数);
```

或者：

```
const 返回值类型 &operator[](参数) const;
```

使用第一种声明方式，[]不仅可以访问数组元素，还可以修改数组元素。

使用第二种声明方式，[]只能访问而不能修改数组元素。

在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应const对象，因为通过const 对象只能调

const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何数组元素。

在重载函数中，可以对下标做合法性检查，防止数组越界。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class CGirl       // 超女类CGirl。
{
private:
    string    m_boys[3];       // 超女的男朋友
public:
    string    m_name;          // 姓名。

    // 默认构造函数。
    CGirl() { m_boys[0] = "子都"; m_boys[1] = "潘安"; m_boys[2] = "宋玉"; }
    // 显示全部男朋友的姓名。
    void show() { cout << m_boys[0] << "、" << m_boys[1] << "、" << m_boys[2] << endl; }
    string& operator[](int ii)
    {
        return m_boys[ii];
    }
    const string& operator[](int ii) const
    {
        return m_boys[ii];
    }
};

int main()
{
    CGirl g;          // 创建超女对象。
    g[1] = "王麻子";
    cout << "第1任男朋友：" << g[1] << endl;
    g.show();

    const CGirl g1 = g;
    cout << "第1任男朋友：" << g1[1] << endl;
}
```

## 重载赋值运算符

C++编译器可能会给类添加四个函数：

- 默认构造函数，空实现。

- 默认析构函数，空实现。

- 默认拷贝构造函数，对成员变量进行浅拷贝。

- 默认赋值函数, 对成员变量进行浅拷贝。

对象的赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值。

如果类的定义中没有重载赋值函数，编译器就会提供一个默认赋值函数。

如果类中重载了赋值函数，编译器将不提供默认赋值函数。

重载赋值函数的语法：类名 & operator=(const 类名 & 源对象);

注意：

- 编译器提供的默认赋值函数，是浅拷贝。

- 如果对象中不存在堆区内存空间，默认赋值函数可以满足需求，否则需要深拷贝。

- 赋值运算和拷贝构造不同：拷贝构造是指原来的对象不存在，用已存在的对象进行构造；赋值运算是指已经存在了两个对象，把其中一个对象的成员变量的值赋给另一个对象的成员变量。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
                     
class CGirl       // 超女类CGirl。
{
public:
    int         m_bh;               // 编号。
    string    m_name;          // 姓名。
    int*        m_ptr;              // 计划使用堆区内存。
                        
    CGirl() { m_ptr = nullptr; }
    ~CGirl() { if (m_ptr)  delete m_ptr;  }
    // 显示全部成员变量。
    void show() { cout << "编号：" << m_bh << "，姓名：" << m_name << "，m_ptr=" << m_ptr <</* "，*m_ptr=" << *m_ptr<< */endl; }
    CGirl& operator=(const CGirl& g)
    {
        if (this == &g) return *this;          // 如果是自己给自己赋值。
        
        if (g.m_ptr == nullptr)    // 如果源对象的指针为空，则清空目标对象的内存和指针。
        {
            if (m_ptr != nullptr) { delete m_ptr; m_ptr = nullptr; }
        }
        else    // 如果源对象的指针不为空。
        {
            // 如果目标对象的指针为空，先分配内存。
            if (m_ptr == nullptr) m_ptr = new int;
            // 然后，把源对象内存中的数据复制到目标对象的内存中。
            memcpy(m_ptr, g.m_ptr, sizeof(int));
        }
                  
        m_bh = g.m_bh; m_name = g.m_name;
        cout << "调用了重载赋值函数。\n" << endl; 
        return *this;
    }
};
                         
int main()
{
    CGirl g1, g2;          // 创建超女对象。
    g1.m_bh = 8; g1.m_name = "西施"; g1.m_ptr = new int(3);
    g1.show();
    g2.show();
              
    g2 = g1;  
    g2.show(); 
    cout << "*g1.m_ptr=" << *g1.m_ptr << "，*g2.m_ptr=" << *g2.m_ptr << endl;
}
```

## 重载new&delete运算符

重载new和delete运算符的目是为了自定义内存分配的细节。（内存池：快速分配和归还，无碎片）

建议先学习C语言的内存管理函数malloc()和free()。

在C++中，使用new时，编译器做了两件事情：

1）调用标准库函数operator new()分配内存；

2）调用构造函数初始化内存；

使用delete时，也做了两件事情：

1）调用析构函数；

2）调用标准库函数operator delete()释放内存。

构造函数和析构函数由编译器调用，我们无法控制。但是，可以重载内存分配函数operator new()和释放函数operator delete()。

1）重载内存分配函数的语法：void* operator new(size_t size);  

- 参数必须是size_t，返回值必须是void*。

2）重载内存释放函数的语法：void operator delete(void* ptr)  

- 参数必须是void *（指向由operator new()分配的内存），返回值必须是void。

- 重载的new和delete可以是全局函数，也可以是类的成员函数。

- 为一个类重载new和delete时，尽管不必显式地使用static，但实际上仍在创建static成员函数。

- 编译器看到使用new创建自定义的类的对象时，它选择成员版本的operator new()而不是全局版本的new()。

- new[]和delete[]也可以重载。

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
                   
void* operator new(size_t size)   // 参数必须是size_t（unsigned long long），返回值必须是void*。
{
	cout << "调用了全局重载的new：" << size << "字节。\n";
	void* ptr = malloc(size);        // 申请内存。
	cout << "申请到的内存的地址是：" << ptr << endl;
	return ptr;
}
                
void operator delete(void* ptr)   // 参数必须是void *，返回值必须是void。
{
	cout << "调用了全局重载的delete。\n";
	if (ptr == 0) return;       // 对空指针delete是安全的。
	free(ptr);      // 释放内存。
}
          
class CGirl       // 超女类CGirl。
{
public:
	int        m_bh;               // 编号。
	int        m_xw;               // 胸围。
                               
	CGirl(int bh, int xw) { m_bh = bh, m_xw = xw;  cout << "调用了构造函数CGirl()\n"; }
	~CGirl() { cout << "调用了析构函数~CGirl()\n"; }
	void* operator new(size_t size)   // 参数必须是size_t（unsigned long long），返回值必须是void*。
	{
		cout << "调用了类的重载的new：" << size << "字节。\n";
		void* ptr = malloc(size);        // 申请内存。
		cout << "申请到的内存的地址是：" << ptr << endl;
		return ptr;
	}
         
	void operator delete(void* ptr)   // 参数必须是void *，返回值必须是void。
	{
		cout << "调用了类的重载的delete。\n";
		if (ptr == 0) return;       // 对空指针delete是安全的。
		free(ptr);      // 释放内存。
	}
};    
     
int main()
{
	int* p1 = new int(3);
	cout << "p1=" << (void *)p1 <<"，*p1=" <<*p1<< endl;
	delete p1;
             
	CGirl* p2 = new CGirl(3, 8);
	cout << "p2的地址是：" << p2 << "编号：" << p2->m_bh << "，胸围：" << p2->m_xw << endl;
	delete p2;
}
```

内存池示例：

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
                  
class CGirl       // 超女类CGirl。
{
public:
	int        m_bh;               // 编号。
	int        m_xw;               // 胸围。
	static char*    m_pool;           // 内存池的起始地址。
                 
	static bool initpool()             // 个初始化内存池的函数。
	{
		m_pool = (char*)malloc(18);           // 向系统申请18字节的内存。
		if (m_pool == 0)  return false;        // 如果申请内存失败，返回false。
		memset(m_pool, 0, 18);                  // 把内存池中的内容初始化为0。
		cout << "内存池的起始地址是：" << (void*)m_pool << endl;
		return true;
	}
               
	static void freepool()                                     // 释放内存池。
	{
		if (m_pool == 0) return;                  // 如果内存池为空，不需要释放，直接返回。
		free(m_pool);                                        // 把内存池归还给系统。
		cout << "内存池已释放。\n";
	}
               
	CGirl(int bh, int xw) { m_bh = bh, m_xw = xw;  cout << "调用了构造函数CGirl()\n"; }
	~CGirl() { cout << "调用了析构函数~CGirl()\n"; }
             
	void* operator new(size_t size)   // 参数必须是size_t（unsigned long long），返回值必须是void*。
	{
		if (m_pool[0] == 0)      // 判断第一个位置是否空闲。
		{
			cout << "分配了第一块内存：" << (void*)(m_pool + 1) << endl;
			m_pool[0] = 1;         // 把第一个位置标记为已分配。
			return m_pool + 1;  // 返回第一个用于存放对象的址。
		}
		if (m_pool[9] == 0)          // 判断第二个位置是否空闲。
		{
			cout << "分配了第二块内存：" << (void*)(m_pool + 9) << endl;
			m_pool[9] = 1;             // 把第二个位置标记为已分配。
			return m_pool + 9;      // 返回第二个用于存放对象的址。
		}
		
		// 如果以上两个位置都不可用，那就直接系统申请内存。
		void* ptr = malloc(size);        // 申请内存。
		cout << "申请到的内存的地址是：" << ptr << endl;
		return ptr;
	}
              
	void operator delete(void* ptr)   // 参数必须是void *，返回值必须是void。
	{
		if (ptr == 0) return;      // 如果传进来的地址为空，直接返回。
                
		if (ptr == m_pool + 1)      // 如果传进来的地址是内存池的第一个位置。
		{
			cout << "释放了第一块内存。\n";
			m_pool[0] = 0;              // 把第一个位置标记为空闲。
			return;
		}
                
		if (ptr == m_pool + 9)      // 如果传进来的地址是内存池的第二个位置。
		{
			cout << "释放了第二块内存。\n";
			m_pool[9] = 0;              // 把第二个位置标记为空闲。
			return;
		}
                 
		// 如果传进来的地址不属于内存池，把它归还给系统。
		free(ptr);      // 释放内存。
	}
};
                      
char* CGirl::m_pool = 0;       // 初始化内存池的指针。
                  
int main()
{           
	// 初始化内存池。
	if (CGirl::initpool()==false) { cout << "初始化内存池失败。\n"; return -1; }

	CGirl* p1 = new CGirl(3, 8);       // 将使用内存池的第一个位置。
	cout << "p1的地址是：" << p1 << "，编号：" << p1->m_bh << "，胸围：" << p1->m_xw << endl;
                  
	CGirl* p2 = new CGirl(4, 7);       // 将使用内存池的第二个位置。
	cout << "p2的地址是：" << p2 << "，编号：" << p2->m_bh << "，胸围：" << p2->m_xw << endl;
                    
	CGirl* p3 = new CGirl(6, 9);       // 将使用系统的内存。
	cout << "p3的地址是：" << p3 << "，编号：" << p3->m_bh << "，胸围：" << p3->m_xw << endl;
                 
	delete p1;    // 将释放内存池的第一个位置。
                 
	CGirl* p4 = new CGirl(5, 3);        // 将使用内存池的第一个位置。
	cout << "p4的地址是：" << p4 << "，编号：" << p4->m_bh << "，胸围：" << p4->m_xw << endl;
        
	delete p2;    // 将释放内存池的第二个位置。
	delete p3;    // 将释放系统的内存。
	delete p4;    // 将释放内存池的第一个位置。
                
	CGirl::freepool();     // 释放内存池。
}

```

## 重载括号运算符

括号[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)()也可以重载，对象名可以当成函数来使用（函数对象、仿函数）。

括号运算符重载函数的语法：

返回值类型 operator()(参数列表);

注意：

- 括号运算符必须以成员函数的形式进行重载。

- 括号运算符重载函数具备普通函数全部的特征。

- 如果函数对象与全局函数同名，按作用域规则选择调用的函数。

函数对象的用途：

1）表面像函数，部分场景中可以代替函数，在STL中得到广泛的应用；

2）函数对象本质是类，可以用成员变量存放更多的信息；

3）函数对象有自己的数据类型；

4）可以提供继承体系。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
           
void show(string str)    // 向超女表白的函数。
{
	cout << "普通函数：" << str << endl;
}
          
class CGirl      // 超女类。
{
public:
	void operator()(string str)    // 向超女表白的函数。
	{
		cout << "重载函数：" << str << endl;
	}
};
           
int main()
{
	CGirl show;
	::show("我是一只傻傻鸟。");
	show("我是一只傻傻鸟。");
}
```

## 重载一元运算符

可重载的一元运算符。

```
1）++ 自增    2）-- 自减   3）! 逻辑非   4）& 取地址

5）~ 二进制反码  6）* 解引用  7）+ 一元加  8） - 一元求反
```

一元运算符通常出现在它们所操作的对象的左边。

但是，自增运算符++和自减运算符--有前置和后置之分。

C++ 规定，重载++或--时，如果重载函数有一个int形参，编译器处理后置表达式时将调用这个重载函数。

成员函数版：CGirl &operator++();       // ++前置

成员函数版：CGirl operator++(int);      // 后置++

非成员函数版：CGirl &operator++(CGirl &);  // ++前置

非成员函数版：CGirl operator++(CGirl &,int); // 后置++

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
          
class CGirl       // 超女类CGirl。
{
public:
    string    m_name;     // 姓名。
    int         m_ranking;  // 排名。
               
    // 默认构造函数。
    CGirl() { m_name = "西施";  m_ranking = 5; }
    // 自我介绍的方法。
    void show() const { cout << "姓名：" << m_name << "，排名：" << m_ranking << endl; }
    CGirl & operator++()         // ++前置的重载函数。
    {
        m_ranking++; return *this;
    }
    CGirl operator++(int)     // ++后置的重载函数。
    {
        CGirl tmp = *this;
        m_ranking++; 
        return tmp;
    }
};
                
int main()
{
    CGirl g1,g2;        // 创建超女对象。
    int ii=5 , jj=5;
    int xx = ++(++(++ii));        cout << "xx=" << xx << ",ii=" << ii << endl;
    int yy = jj++;                       cout << "yy=" << yy << ",jj=" << jj << endl;
    CGirl g3 = ++(++(++g1));   cout << "g3.m_ranking=" << g3.m_ranking << ",g1.m_ranking=" << g1.m_ranking << endl;
    CGirl g4 = g2++;                   cout << "g4.m_ranking=" << g4.m_ranking << ",g2.m_ranking=" << g2.m_ranking << endl;
    // g2.show();
}
```

## 自动类型转换

对于内置类型，如果两种数据类型是兼容的，C++可以自动转换，如果从更大的数转换为更小的数，可能会被截断或损失精度。

```
long count = 8;        // int转换为long
double time = 11;      // int转换为double
int side = 3.33         // double转换为int的3
```

C++不自动转换不兼容的类型，下面语句是非法的：

```
int* ptr = 8;
```

不能自动转换时，可以使用强制类型转换：

```
int* p = (int*)8; 
```

**如果某种类型与类相关，从某种类型转换为类类型是有意义的。**

```
string str = "我是一只傻傻鸟。";
```

在C++中，将一个参数的构造函数用作自动类型转换函数，它是自动进行的，不需要显式的转换。

```
CGirl g1(8);          // 常规的写法。
CGirl g1 = CGirl(8);   // 显式转换。
CGirl g1 = 8;         // 隐式转换。
CGirl g1;             // 创建对象。
g1 = 8;              // 隐式转换，用CGirl(8)创建临时对象，再赋值给g。
```

注意：

1）一个类可以有多个转换函数。

2）多个参数的构造函数，除第一个参数外，如果其它参数都有缺省值，也可以作为转换函数。

3）CGirl(int)的隐式转换的场景：

- 将CGirl对象初始化为int值时。  CGirl g1 = 8;

- 将int值赋给CGirl对象时。    CGirl g1; g1 = 8;

- 将int值传递给接受CGirl参数的函数时。

- 返回值被声明为CGirl的函数试图返回int值时。

- 在上述任意一种情况下，使用可转换为int类型的内置类型时。

4）如果自动类型转换有二义性，编译将报错。

将构造函数用作自动类型转换函数似乎是一项不错的特性，但有时候会导致意外的类型转换。explicit关键字用于关闭这种自动特性，但仍允许显式转换。

```
explicit CGirl(int bh);
CGirl g=8;        // 错误。
CGirl g=CGirl(8);  // 显式转换，可以。
CGirl g=(CGirl)8;  // 显式转换，可以。
```

在实际开发中，如果强调的是构造，建议使用explicit，如果强调的是类型转换，则不使用explicit。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
           
class CGirl       // 超女类CGirl。
{           
public:
    int         m_bh;           // 编号。
    string    m_name;     // 姓名。
    double  m_weight;   // 体重，单位：kg。
                
    // 默认构造函数。
    CGirl() { m_bh = 0;  m_name.clear();  m_weight = 0; cout << "调用了CGirl()\n"; }
    // 自我介绍的方法。
    void show() { cout << "bh=" << m_bh << ",name=" << m_name << ",weight=" << m_weight << endl; }
    explicit CGirl(int bh) { m_bh = bh;  m_name.clear();  m_weight = 0; cout << "调用了CGirl(int bh)\n"; }
    //CGirl(double weight) { m_bh = 0;  m_name.clear();  m_weight = weight; cout << "调用了CGirl(double weight)\n"; }
};     
          
int main()
{       
    //CGirl g1(8);                // 常规的写法。
    //CGirl g1 = CGirl(8);   // 显式转换。
    //CGirl g1 = 8;             // 隐式转换。
    CGirl g1;                    // 创建对象。
    g1 = (CGirl)8;                      // 隐式转换，用CGirl(8)创建临时对象，再赋值给g。
    //CGirl g1 = 8.7;             // 隐式转换。
    //g1.show();
}    
```

## 转换函数

构造函数只用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数-转换函数。

语法：operator 数据类型();

**注意：转换函数必须是类的成员函数；不能指定返回值类型；不能有参数。**

可以让编译器决定选择转换函数（隐式转换），可以像使用强制类型转换那样使用它们（显式转换）。

```
int ii=girl;       // 隐式转换。
int ii=(int) girl;  // 显式转换。
int ii=int(girl);   // 显式转换。
```

如果隐式转换存在二义性，编译器将报错。

在C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制，可以将转换函数声明为显式的。

还有一种方法是：用一个功能相同的普通成员函数代替转换函数，普通成员函数只有被调用时才会执行。

```
int ii=girl.to_int();
```

警告：应谨慎的使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的成员函数。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
         
class CGirl       // 超女类CGirl。
{   
public:
    int         m_bh;           // 编号。
    string    m_name;     // 姓名。
    double  m_weight;   // 体重，单位：kg。
               
    // 默认构造函数。
    CGirl() { m_bh = 8;  m_name="西施";  m_weight = 50.7; }
    explicit operator int()  { return m_bh; }
    int to_int() { return m_bh; }
    operator string() { return m_name; }
    explicit operator double() { return m_weight; }
};    
            
int main()
{         
    string name = "西施";                 // char * 转换成 string
    const char* ptr = name;             // string 转换成 char *，错误
    const char* ptr = name.c_str();  // 返回char *，正确
            
    CGirl g;
    int a = g.to_int();         cout << "a的值是：" << a << endl;
    string b = string(g);    cout << "b的值是：" << b << endl;
    double c = double(g);  cout << "c的值是：" << c << endl;
    short d = (int)g;
}
```

## 继承的基本概念

继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。

语法：

```
class 派生类名:［继承方式］基类名
{
  派生类新增加的成员
}; 
```

被继承的类称为基类或父类，继承的类称为派生类或子类。

继承和派生是一个概念，只是站的角度不同。

派生类除了拥有基类的成员，还可以定义新的成员，以增强其功能。

使用继承的场景：

1) 如果新创建的类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承。
2) 当需要创建多个类时，如果它们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
           
class CAllComers          // 海选报名者类
{           
public:
    string    m_name;    // 姓名
    string    m_tel;         // 联系电话
                 
    // 构造函数。
    CAllComers() { m_name = "某女"; m_tel = "不详"; }
    // 报名时需要唱一首歌。
    void sing() { cout << "我是一只小小鸟。\n"; }
    // 设置姓名。
    void setname(const string& name) { m_name = name; }
    // 设置电话号码。
    void settel(const string& tel) { m_tel = tel; }
};     
         
class CGirl :public CAllComers        // 超女类
{           
public:
    int m_bh;          // 编号。
    CGirl() { m_bh = 8;  }
    void show() { cout << "编号：" << m_bh << "，姓名：" << m_name << "，联系电话：" << m_tel << endl; }
};           
             
int main()
{        
    CGirl g;
    g.setname("西施");
    g.show();
}
```

## 继承方式

类成员的访问权限由高到低依次为：public --> protected --> private，public成员在类外可以访问，private成员只能在类的成员函数中访问。

如果不考虑继承关系，protected成员和private成员一样，类外不能访问。但是，当存在继承关系时，protected和private就不一样了。基类中的protected成员可以在派生类中访问，而基类中的 private成员不能在派生类中访问。

继承方式有三种：public（公有的）、protected（受保护的）和[private](https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020)（私有的）。它是可选的，如果不写，那么默认为private。不同的继承方式决定了在派生类中成员函数中访问基类成员的权限。

![image-20230928174037533](./photo/image-20230928174037533-1695895867680-4.png)

1）基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为protected时，那么基类成员在派生类中的访问权限最高也为protected，高于protected的会降级为protected，但低于protected不会升级。再如，当继承方式为public时，那么基类成员在派生类中的访问权限将保持不变。

也就是说，继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。

2) **不管继承方式如何，基类中的private成员在派生类中始终不能使用**（不能在派生类的成员函数中访问或调用）。
3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为public 或protected；只有那些不希望在派生类中使用的成员才声明为private。
4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。

由于private和protected继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以，**在实际开发中，一般使用public**。

**在派生类中，可以通过基类的公有成员函数间接访问基类的私有成员。**

**使用 using 关键字可以改变基类成员在派生类中的访问权限。**

注意：using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类中的private成员在派生类中是不可见的，根本不能使用。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class A  {        // 基类
public:
    int m_a=10;
protected:
    int m_b=20;
private:
    int m_c = 30;
};

class B :public A        // 派生类
{
public:
    using A::m_b;         // 把m_b的权限修改为公有的。
private:
    using A::m_a;         // 把m_a的权限修改为私有的。
};

int main()
{
    B b;   
    // b.m_a = 11;
    b.m_b = 21;
    //b.m_c = 21;
}
```

## 继承的对象模型

1）创建派生类对象时，先调用基类的构造函数，再调用派生类的构造函数。

2）销毁派生类对象时，先调用派生类的析构函数，再调用基类的析构函数。**如果手工调用派生类的析构函数，也会调用基类的析构函数。**

3）创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this指针相同的。

4）创建派生类对象时，先初始化基类对象，再初始化派生类对象。

5）在VS中，用cl.exe可以查看类的内存模型。

6）对派生类对象用sizeof得到的是基类所有成员（包括私有成员）+派生类对象所有成员的大小。

7）在C++中，不同继承方式的访问权限只是语法上的处理。

8）对派生类对象用memset()会清空基类私有成员。

9）用指针可以访问到基类中的私有成员（内存对齐）。

查看对象内存布局的方法：

```
cl 源文件名 /d1 reportSingleClassLayout类名
```

**注意：类名不要太短，否则屏幕会显示一大堆东西，找起来很麻烦。**

例如，查看BBB类，源代码文件是demo01.cpp：

```
cl demo01.cpp /d1 reportSingleClassLayoutBBB
```

cl命令环境变量：

1）在PATH环境变量中增加cl.exe的目录

```
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\bin\Hostx64\x64
```

2）增加INCLUDE环境变量，内容如下：

```
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\winrt
```

3）增加LIB环境变量，内容如下：

```
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\lib\x64
C:\Program Files (x86)\Windows Kits\10\Lib\10.0.19041.0\um\x64
C:\Program Files (x86)\Windows Kits\10\Lib\10.0.19041.0\ucrt\x64
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
            
void* operator new(size_t size)   // 重载new运算符。
{
    void* ptr = malloc(size);        // 申请内存。
    cout << "申请到的内存的地址是：" << ptr << "，大小是：" << size << endl;
    return ptr;
}
               
void operator delete(void* ptr)   // 重载delete运算符。
{
    if (ptr == 0) return;       // 对空指针delete是安全的。
    free(ptr);      // 释放内存。
    cout << "释放了内存。\n";
}
              
class A {        // 基类
public:
    int m_a = 10;
protected:
    int m_b = 20;
private:
    int m_c = 30;
public:
    A() {
        cout << "A中this指针是： " << this << endl;
        cout << "A中m_a的地址是：" << &m_a << endl;
        cout << "A中m_b的地址是：" << &m_b << endl;
        cout << "A中m_c的地址是：" << &m_c << endl;
    }
    void func() { cout << "m_a=" << m_a << ",m_b=" << m_b << ",m_c=" << m_c << endl; }
};
                 
class B :public A        // 派生类
{
public:
    int m_d = 40;
    B() {
        cout << "B中this指针是： " << this << endl;
        cout << "B中m_a的地址是：" << &m_a << endl;
        cout << "B中m_b的地址是：" << &m_b << endl;
        //cout << "B中m_c的地址是：" << &m_c << endl;
        cout << "B中m_d的地址是：" << &m_d << endl;
    }
    void func1() { cout << "m_d=" << m_d << endl; }
};
                
int main()
{
    cout << "基类占用内存的大小是：" << sizeof(A) << endl;
    cout << "派生类占用内存的大小是：" << sizeof(B) << endl;
              
    B *p=new B;
    p->func(); p->func1();
    // memset(p, 0, sizeof(B));
    *((int*)p + 2) = 31;        // 把基类私有成员m_c的值修改成31。
    p->func(); p->func1();
    delete p;
}
```

## 如何构造基类

派生类构造函数的要点如下： 

1）创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。

2）如果没以指定基类构造函数，将使用基类的默认构造函数。

3）可以用初始化列表指明要使用的基类构造函数。

4）基类构造函数负责初始化被继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。

5）派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
               
class A {        // 基类
public:
    int m_a;
private:
    int m_b;
public:
    A() : m_a(0) , m_b(0)                     // 基类的默认构造函数。
    { 
        cout << "调用了基类的默认构造函数A()。\n";  
    }
    A(int a,int b) : m_a(a) , m_b(b)     // 基类有两个参数的构造函数。
    { 
        cout << "调用了基类的构造函数A(int a,int b)。\n";  
    }
    A(const A &a) : m_a(a.m_a+1) , m_b(a.m_b+1)   // 基类的拷贝构造函数。
    {
        cout << "调用了基类的拷贝构造函数A(const A &a)。\n";
    }
               
    // 显示基类A全部的成员。
    void showA() { cout << "m_a=" << m_a << ",m_b=" << m_b << endl; }
};
               
class B :public A        // 派生类
{        
public:
    int m_c;
    B() : m_c(0) , A()             // 派生类的默认构造函数，指明用基类的默认构造函数（不指明也无所谓）。
    {
        cout << "调用了派生类的默认构造函数B()。\n";
    }
    B(int a, int b, int c) : A(a, b), m_c(c)           // 指明用基类的有两个参数的构造函数。
    {
        cout << "调用了派生类的构造函数B(int a,int b,int c)。\n";
    }
    B(const A& a, int c) :A(a), m_c(c)              // 指明用基类的拷贝构造函数。
    {
        cout << "调用了派生类的构造函数B(const A &a,int c) 。\n";
    }
           
    // 显示派生类B全部的成员。
    void showB() { cout << "m_c=" << m_c << endl << endl; }
};          
             
int main()
{
    B b1;                 // 将调用基类默认的构造函数。
    b1.showA();     b1.showB();
       
    B b2(1, 2, 3);      // 将调用基类有两个参数的构造函数。
    b2.showA();     b2.showB();
            
    A a(10, 20);      // 创建基类对象。
    B b3(a, 30);      // 将调用基类的拷贝造函数。
    b3.showA();     b3.showB();
}    
```

## 名字遮蔽与类作用域

如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，将使用派生类新增的成员，而不是基类的。

注意：基类的成员函数和派生类的成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数。

类是一种作用域，每个类都有它自己的作用域，在这个作用域之内定义成员。

在类的作用域之外，普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问，静态成员可以通过对象访问，也可以通过类访问。

在成员名前面加类名和域解析符可以访问对象的成员。

如果不存在继承关系，类名和域解析符可以省略不写。

当存在继承关系时，基类的作用域嵌套在派生类的作用域中。如果成员在派生类的作用域中已经找到，就不会在基类作用域中继续查找；如果没有找到，则继续在基类作用域中查找。

如果在成员的前面加上类名和域解析符，就可以直接使用该作用域的成员。

![image-20230928175101752](./photo/image-20230928175101752-1695895903341-9.png)

```c++
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
               
class A {        // 基类
public:
    int m_a=10;
    void func() { cout << "调用了A的func()函数。\n"; }
};
               
class B :public A {       // 子类
public:
    int m_a = 20;
    void func() { cout << "调用了B的func()函数。\n"; }
};
           
class C :public B {       // 孙类
public:
    int m_a = 30;
    void func() { cout << "调用了C的func()函数。\n"; }
    void show() {
        cout << "C::m_a的值是：" << C::m_a << endl;
        cout << "B::m_a的值是：" << B::m_a << endl;
        cout << "A::m_a的值是：" << B::A::m_a << endl;
    }
};
           
int main()
{           
    C c;
    cout << "C::m_a的值是：" << c.C::m_a << endl;
    cout << "B::m_a的值是：" << c.B::m_a << endl;
    cout << "A::m_a的值是：" << c.B::A::m_a << endl;
    c.C::func();
    c.B::func();
    c.B::A::func();
}
```

## 继承的特殊关系

派生类和基类之间有一些特殊关系。

1）如果继承方式是公有的，派生类对象可以使用基类成员。

2）可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。

3）基类指针可以在不进行显式转换的情况下指向派生类对象。

4）基类引用可以在不进行显式转换的情况下引用派生类对象。

注意：

1）基类指针或引用只能调用基类的方法，不能调用派生类的方法。

2）可以用派生类构造基类。

3）如果函数的形参是基类，实参可以用派生类。

4）C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外。但是，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针（没有价值，没有讨论的必要）。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class A {        // 基类
public:
    int m_a=0;
private:
    int m_b=0;
public:
    // 显示基类A全部的成员。
    void show() { cout << "A::show() m_a=" << m_a << ",m_b=" << m_b << endl; }
    // 设置成员m_b的值。
    void setb(int b) { m_b = b;  }
};

class B :public A        // 派生类
{
public:
    int m_c=0;
    // 显示派生类B全部的成员。
    void show() { cout << "B::show() m_a=" << m_a << "m_c=" << m_c << endl; }
};

int main()
{
    B b;
    A* a = &b;

    b.m_a = 10; 
    b.setb(20);          // 设置成员m_b的值。
    b.m_c = 30;
    b.show();            // 调用的是B类的show()函数。

    a->m_a = 11;
    a->setb(22);          // 设置成员m_b的值。
    // a->m_c = 30;
    
    a->show();         // 调用的是A类的show()函数。
}
```

## 多继承与虚继承

多继承的语法：

```
class 派生类名 : [继承方式1] 基类名1, [继承方式2] 基类名2,......
{
    派生类新增加的成员
};
```

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
            
class A1 {        // 基类一
public:
    int m_a = 10;
};
       
class A2 {        // 基类二
public:
    int m_a = 20;
};
         
class B :public A1, public A2 {       // 派生类
public:
    int m_a = 30;
};
       
int main()
{
    B b;
    cout << " B::m_a的值是：" << b.m_a << endl;
    cout << "A1::m_a的值是：" << b.A1::m_a << endl;
    cout << "A2::m_a的值是：" << b.A2::m_a << endl;
}
```

菱形继承：

![image-20230928175641391](./photo/image-20230928175641391.png)

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class A {    
public:
    int m_a = 10;
};

class B : virtual public A { };

class C : virtual public A { };

class DD : public B, public C {};

int main()
{
    DD d;
    // d.B::m_a = 30;
    // d.C::m_a = 80;
    d.m_a = 80;
    cout << "B::m_a的地址是：" << &d.B::m_a << "，值是：" << d.B::m_a << endl;
    cout << "C::m_a的地址是：" << &d.C::m_a << "，值是：" << d.C::m_a << endl;
}
```

虚继承可以解决菱形继承的**二义性**和**数据冗余**的问题。

有了多继承，就存在菱形继承，有了菱形继承就有虚继承，增加了复杂性。

**不提倡使用多继承，只有在比较简单和不出现二义性的情况时才使用多继承，能用单一继承解决的问题就不要使用多继承。**

如果继承的层次很多、关系很复杂，程序的编写、调试和维护工作都会变得更加困难，由于这个原因，C++之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。

## 多态的基本概念

基类指针只能调用基类的成员函数，不能调用派生类的成员函数。

如果在基类的成员函数前加virtual 关键字，把它声明为虚函数，基类指针就可以调用派生类中同名的成员函数，通过派生类中同名的成员函数，就可以访问派生对象的成员变量。

有了虚函数，基类指针指向基类对象时就使用基类的成员函数和数据，指向派生类对象时就使用派生类的成员函数和数据，基类指针表现出了多种形式，这种现象称为多态。

基类引用也可以使用多态。

注意：

1）只需要在基类的函数声明中加上virtual关键字，函数定义时不能加。

2）在派生类中重定义虚函数时，函数特征要相同。

3）当在基类中定义了虚函数时，如果派生类没有重定义该函数，那么将使用基类的虚函数。

4）在派生类中重定义了虚函数的情况下，如果想使用基类的虚函数，可以加类名和域解析符。

5）如果要在派生类中重新定义基类的函数，则将它设置为虚函数；否则，不要设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
            
class CAllComers {        // 报名者类
public:
    int  m_bh = 0;             // 编号。
    virtual void show() { cout << "CAllComers::show()：我是" << m_bh << "号。 " << endl; }
    virtual void show(int a) { cout << "CAllComers::show(int a)：我是" << m_bh << "号。 " << endl; }
};
             
class CGirl :public CAllComers {        // 超女类
public:
    int m_age = 0;           // 年龄。
    void show() { cout << "CGirl::show()：我是" << m_bh << "号， " << m_age << "岁。" << endl; }
    void show(int a) { cout << "CGirl::show(int a)：我是" << m_bh << "号， " << m_age << "岁。" << endl; }
};
        
int main()
{        
    CAllComers a;  a.m_bh = 3;                             // 创建基类对象并对成员赋值。
    CGirl g;             g.m_bh = 8; g.m_age = 23;    // 创建派生类对象并对成员赋值。
            
    CAllComers* p;            // 声明基类指针。
    //p = &a;   p->show();   // 让基类指针指向基类对象，并调用虚函数。
    p = &g;   p->show();   // 让基类指针指向派生类对象，并调用虚函数。
    p->show(5); 
    p->CAllComers::show(5);
}
```

## 多态的应用场景

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
         
class Hero                        // 英雄基类
{
public:
	int viability;      // 生存能力。
	int attack;         // 攻击伤害。
	virtual void skill1() { cout << "英雄释放了一技能。\n"; }
	virtual void skill2() { cout << "英雄释放了二技能。\n"; }
	virtual void uskill() { cout << "英雄释放了大绝招。\n"; }
};
           
class XS :public Hero       // 西施派生类
{
public:
	void skill1() { cout << "西施释放了一技能。\n"; }
	void skill2() { cout << "西施释放了二技能。\n"; }
	void uskill() { cout << "西施释放了大招。\n"; }
};
              
class HX :public Hero       // 韩信派生类
{
public:
	void skill1() { cout << "韩信释放了一技能。\n"; }
	void skill2() { cout << "韩信释放了二技能。\n"; }
	void uskill() { cout << "韩信释放了大招。\n"; }
};
                
class LB :public Hero       // 李白派生类
{
public:
	void skill1() { cout << "李白释放了一技能。\n"; }
	void skill2() { cout << "李白释放了二技能。\n"; }
	void uskill() { cout << "李白释放了大招。\n"; }
};
              
int main()
{
	// 根据用户选择的英雄，施展一技能、二技能和大招。
	int id = 0;     // 英雄的id。
	cout << "请输入英雄（1-西施；2-韩信；3-李白。）：";
	cin >> id;
               
	// 创建基类指针，让它指向派生类对象，用基类指针调用派生类的成员函数。
	Hero* ptr = nullptr;
	if (id == 1)	{             // 1-西施
		ptr=new XS;  
	}
	else if (id == 2) {      // 2-韩信
		ptr = new HX;
	}
	else if (id == 3) {      // 3-李白
		ptr = new LB;
	}
           
	if (ptr != nullptr) {
		ptr->skill1();
		ptr->skill2();
		ptr->uskill();
		delete ptr;
	}
}
```

## 多态的对象模型

类的普通成员函数的地址是静态的，在编译阶段已指定。

如果基类中有虚函数，对象的内存模型中有一个虚函数表，表中存放了基类的函数名和地址。

如果派生类中重定义了基类的虚函数，创建派生类对象时，将用派生类的函数取代虚函数表中基类的函数。

C++中的多态分为两种：静态多态与动态多态。

静态多态：也成为编译时的多态；在编译时期就已经确定要执行了的函数地址了；主要有函数重载和函数模板。

动态多态：即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，一般用于解决基类指针或引用派生类对象调用类中重写的方法（函数）时出现的问题。

## 如何析构派生类

构造函数不能继承，创建派生类对象时，先执行基类构造函数，再执行派生类构造函数。

析构函数不能继承，而销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数。

派生类的析构函数在执行完后，会自动执行基类的析构函数。

如果手工的调用派生类的析构函数，也会自动调用基类的析构函数。

析构派生类的要点如下： 

1）析构派生类对象时，会自动调用基类的析构函数。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。

2）析构函数可以手工调用，如果对象中有堆内存，析构函数中以下代码是必要的：

delete ptr;

ptr=nulllptr;

3）用基类指针指向派生类对象时，delete基类指针调用的是基类的析构函数，不是派生类的，如果希望调用派生类的析构函数，就要把基类的析构函数设置为虚函数。

4）C++编译器对虚析构函数做了特别的处理。

5）对于基类，即使它不需要析构函数，也应该提供一个空虚析构函数。

6）赋值运算符函数不能继承，派生类继承的函数的特征标与基类完全相同，但赋值运算符函数的特征标随类而异，它包含了一个类型为其所属类的形参。

7）友元函数不是类成员，不能继承。

​		构造函数是不能继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。然而，派生类构造函数通常使用成员初始化列表语法来调用基类构造函数，以创建派生对象的基类部分。如果派生类构造函数没有使用成员初始化列表语法显式调用基类构造函数，将使用基类的默认构造函数。在继承链中，每个类都可以使用成员初始化列表将信息传递给相邻的基类。C++11 新增了一种让您能够继承构造函数的机制，但默认仍不继承构造函数。

​		析构函数也是不能继承的。然而，在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。

​		通常，对于基类，其析构函数应设置为虚的。赋值运算符是不能继承的，原因很简单。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，这是因为它包含一个类型为其所属类的形参。

​		由于友元函数并非类成员，因此不能继承。然而，您可能希望派生类的友元函数能够使用基类的友元函数。为此，可以通过强制类型转换将，派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
          
class AA {                    // 基类
public:
	AA() { cout << "调用了基类的构造函数AA()。\n"; }
	virtual void func() { cout << "调用了基类的func()。\n"; 	}
	// virtual ~AA() { cout << "调用了基类的析构函数~AA()。\n"; }
	virtual ~AA() {}
};
            
class BB:public AA  {  // 派生类
public:
	BB() { cout << "调用了派生类的构造函数BB()。\n"; }
	void func() { cout << "调用了派生类的func()。\n"; }
	~BB() { cout << "调用了派生类的析构函数~BB()。\n"; }
};
         
int main()
{
	AA *a=new BB;
	delete a;
}
```

## 纯虚函数和抽象类

​		纯虚函数是一种特殊的虚函数，在某些情况下，基类中不能对虚函数给出有意义的实现，把它声明为纯虚函数。纯虚函数只有函数名、参数和返回值类型，没有函数体，具体实现留给该派生类去做。

语法：virtual 返回值类型 函数名 (参数列表)=0;

​		纯虚函数在基类中为派生类保留一个函数的名字，以便派生类它进行重定义。如果在基类中没有保留函数名字，则无法支持多态性。含有纯虚函数的类被称为抽象类，不能实例化对象，可以创建指针和引用。派生类必须重定义抽象类中的纯虚函数，否则也属于抽象类。基类中的纯虚析构函数也需要实现。
​		有时候，想使一个类成为抽象类，但刚好又没有任何纯虚函数，怎么办？方法很简单：在想要成为抽象类的类中声明一个纯虚析构函数。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。
     
class AA {                    // 基类
public:
	AA() { cout << "调用了基类的构造函数AA()。\n"; }
	virtual void func() = 0  { cout << "调用了基类的func()。\n"; }
	virtual ~AA() = 0 { cout << "调用了基类的析构函数~AA()。\n"; }
};
      
class BB :public AA {  // 派生类
public:
	BB() { cout << "调用了派生类的构造函数BB()。\n"; }
	void func() { cout << "调用了派生类的func()。\n"; }
	~BB() { cout << "调用了派生类的析构函数~BB()。\n"; }
};
            
int main()
{
	BB b; 
	AA &r = b;
	r.func();
}
```

## 运行阶段类型识别dynamic_cast

运行阶段类型识别（RTTI RunTime Type Identification）为程序在运行阶段确定对象的类型，**只适用于包含虚函数的类**。

基类指针可以指向派生类对象，如何知道基类指针指向的是哪种派生类的对象呢？（想调用派生类中的非虚函数）。

dynamic_cast运算符用指向基类的指针来生成派生类的指针，它不能回答“指针指向的是什么类的对象”的问题，但能回答“是否可以安全的将对象的地址赋给特定类的指针”的问题。

语法：派生类指针 = dynamic_cast<派生类类型 *>(基类指针);

如果转换成功，dynamic_cast返回对象的地址，如果失败，返回nullptr。

注意：

1）dynamic_cast只适用于包含虚函数的类。

2）dynamic_cast可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。

3）dynamic_cast可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现bad_cast异常。

```
#include <iostream>         // 包含头文件。
using namespace std;        // 指定缺省的命名空间。

class Hero                        // 英雄基类
{
public:
	int viability;      // 生存能力。
	int attack;         // 攻击伤害。
	virtual void skill1() { cout << "英雄释放了一技能。\n"; }
	virtual void skill2() { cout << "英雄释放了二技能。\n"; }
	virtual void uskill() { cout << "英雄释放了大绝招。\n"; }
};

class XS :public Hero       // 西施派生类
{
public:
	void skill1() { cout << "西施释放了一技能。\n"; }
	void skill2() { cout << "西施释放了二技能。\n"; }
	void uskill() { cout << "西施释放了大招。\n"; }
	void show() { cout << "我是天下第一美女。\n"; }
};

class HX :public Hero       // 韩信派生类
{
public:
	void skill1() { cout << "韩信释放了一技能。\n"; }
	void skill2() { cout << "韩信释放了二技能。\n"; }
	void uskill() { cout << "韩信释放了大招。\n"; }
};

class LB :public Hero       // 李白派生类
{
public:
	void skill1() { cout << "李白释放了一技能。\n"; }
	void skill2() { cout << "李白释放了二技能。\n"; }
	void uskill() { cout << "李白释放了大招。\n"; }
};

int main()
{
	// 根据用户选择的英雄，施展一技能、二技能和大招。
	int id = 0;     // 英雄的id。
	cout << "请输入英雄（1-西施；2-韩信；3-李白。）：";
	cin >> id;

	// 创建基类指针，让它指向派生类对象，用基类指针调用派生类的成员函数。
	Hero* ptr = nullptr;
	if (id == 1) {             // 1-西施
		ptr = new XS;
	}
	else if (id == 2) {      // 2-韩信
		ptr = new HX;
	}
	else if (id == 3) {      // 3-李白
		ptr = new LB;
	}

	if (ptr != nullptr) {
		ptr->skill1();
		ptr->skill2();
		ptr->uskill();

		// 如果基类指针指向的对象是西施，那么就调用西施的show()函数。
		//if (id == 1) {
		//	XS* pxs = (XS *)ptr;        // C风格强制转换的方法，程序员必须保证目标类型正确。
		//	pxs->show();
		//}
		XS* xsptr = dynamic_cast<XS*>(ptr);         // 把基类指针转换为派生类。
		if (xsptr != nullptr) xsptr->show();              // 如果转换成功，调用派生类西施的非虚函数。

		delete ptr;
	}

	// 以下代码演示把基类引用转换为派生类引用时发生异常的情况。
	/*HX hx;
	Hero& rh = hx;
	try{
		XS & rxs= dynamic_cast<XS &>(rh);
	}
	catch (bad_cast) {
		cout << "出现了bad_cast异常。\n";
	}*/
}
```

## typeid运算符和type_info类

typeid运算符用于获取数据类型的信息。

l 语法一：typeid(数据类型);

l 语法二：typeid(变量名或表达式);

typeid运算符返回type_info类（在头文件<typeinfo>中定义）的对象的引用。

type_info类的实现随编译器而异，但至少有name()成员函数，该函数返回一个字符串，通常是类名。

type_info重载了==和!=运算符，用于对类型进行比较。

注意：

1）type_info类的构造函数是private属性，也没有拷贝构造函数，所以不能直接实例化，只能由编译器在内部实例化。

2）不建议用name()成员函数返回的字符串作为判断数据类型的依据。（编译器可能会转换类型名）

3）typeid运算符可以用于多态的场景，在运行阶段识别对象的数据类型。

4）假设有表达式typeid(***ptr**)，当ptr是空指针时，如果ptr是多态的类型，将引发bad_typeid异常。

```
#include <iostream>
#include <string>
using namespace std; 

class AA {   // 定义一个类。
public: 
    AA() {} 
};

int main()
{
    // typeid用于自定义的数据类型。
    AA aa;
    AA* paa = &aa;
    AA& raa = aa;
    cout << "typeid(AA)=" << typeid(AA).name() << endl;
    cout << "typeid(aa)=" << typeid(aa).name() << endl;
    cout << "typeid(AA *)=" << typeid(AA*).name() << endl;
    cout << "typeid(paa)=" << typeid(paa).name() << endl;
    cout << "typeid(AA &)=" << typeid(AA&).name() << endl;
    cout << "typeid(raa)=" << typeid(raa).name() << endl;

    // type_info重载了==和!=运算符，用于对类型进行比较。
    if (typeid(AA) == typeid(aa))     cout << "ok1\n";
    if (typeid(AA) == typeid(*paa)) cout << "ok2\n";
    if (typeid(AA) == typeid(raa))    cout << "ok3\n";
    if (typeid(AA*) == typeid(paa))   cout << "ok4\n";

    return 0;
}
```

